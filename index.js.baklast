require('dotenv').config();
const {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ApplicationCommandOptionType,
  REST,
  Routes,
  StringSelectMenuBuilder
} = require('discord.js');
const axios = require('axios');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');

// Discord client setup
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// Configuration
const config = {
  discordToken: process.env.DISCORD_TOKEN,
  discordAppId: process.env.DISCORD_APP_ID,
  refreshInterval: parseInt(process.env.REFRESH_INTERVAL) || 45000, // Default to 45 seconds
  // Add whitelist configuration - comma-separated list of guild IDs
  whitelistedGuilds: []
};

// Parse whitelist from environment variable
if (process.env.WHITELISTED_GUILDS) {
  const whitelistString = process.env.WHITELISTED_GUILDS.trim();
  if (whitelistString) {
    config.whitelistedGuilds = whitelistString.split(',').map(id => id.trim());
    console.log(`Loaded ${config.whitelistedGuilds.length} whitelisted guild IDs from .env`);
  }
}

// API key management
const apiKeyManager = {
  reservoirKeys: [
    'c65ab60c-61a5-5e1c-bb44-d4cc4c0af8a0', // Main key
    '25ce7c8c-767e-55b0-a37f-61054669a66f',  // Second key
    'ca6c8417-f285-529a-b7fa-13d394a10125'   // Third key
  ],
  currentKeyIndex: 0,
  rateLimitDetected: {},
  lastQueryTimes: {}, // Track timestamps of recent queries for each key
  
  getCurrentKey() {
    return this.reservoirKeys[this.currentKeyIndex];
  },
  
  async waitForRateLimit() {
    const currentKey = this.getCurrentKey();
    const now = Date.now();
    
    if (!this.lastQueryTimes[currentKey]) {
      this.lastQueryTimes[currentKey] = [];
    }
    
    this.lastQueryTimes[currentKey] = this.lastQueryTimes[currentKey].filter(
      time => now - time < 1000
    );
    
    if (this.lastQueryTimes[currentKey].length >= 2) {
      const oldestQuery = this.lastQueryTimes[currentKey][0];
      const waitTime = Math.max(0, 1000 - (now - oldestQuery));
      
      if (waitTime > 0) {
        console.log(`Rate limit approaching for key ${this.maskApiKey(currentKey)}, waiting ${waitTime}ms`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    this.lastQueryTimes[currentKey].push(Date.now());
  },
  
  resetRateLimits() {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    
    for (const key in this.rateLimitDetected) {
      if (this.rateLimitDetected[key] < oneHourAgo) {
        delete this.rateLimitDetected[key];
      }
    }
    
    for (const key in this.lastQueryTimes) {
      this.lastQueryTimes[key] = this.lastQueryTimes[key].filter(
        time => now - time < 1000
      );
    }
  },
  
  maskApiKey(key) {
    if (!key || key.length < 8) return '****';
    return `${key.substring(0, 4)}...${key.substring(key.length - 4)}`;
  },
  
  rotateKey() {
    const previousKey = this.getCurrentKey();
    const now = Date.now();
    
    // Mark current key as rate limited
    this.rateLimitDetected[previousKey] = now;
    
    // Try to find a key that hasn't been rate limited in the last 5 minutes
    const fiveMinutesAgo = now - (5 * 60 * 1000);
    let foundUsableKey = false;
    
    // Store initial index to detect if we've checked all keys
    const initialIndex = this.currentKeyIndex;
    
    // Try all keys
    for (let i = 0; i < this.reservoirKeys.length; i++) {
      // Advance to next key
      this.currentKeyIndex = (this.currentKeyIndex + 1) % this.reservoirKeys.length;
      const nextKey = this.getCurrentKey();
      
      // If this key isn't rate limited, use it
      if (!this.rateLimitDetected[nextKey] || this.rateLimitDetected[nextKey] < fiveMinutesAgo) {
        foundUsableKey = true;
        console.log(`Rotating from API key ${this.maskApiKey(previousKey)} to ${this.maskApiKey(nextKey)}`);
        break;
      }
    }
    
    if (!foundUsableKey) {
      console.log(`All API keys are rate limited, using key ${this.maskApiKey(this.getCurrentKey())}`);
    }
    
    return this.getCurrentKey();
  },
  
  handleApiError(error) {
    // Check if this is a rate limit error (429 Too Many Requests or 403 Forbidden)
    if (error.response && (error.response.status === 429 || error.response.status === 403)) {
      console.log(`Rate limit detected for API key ${this.maskApiKey(this.getCurrentKey())}`);
      
      if (this.reservoirKeys.length <= 1) {
        console.log(`‚ö†Ô∏è Only one API key available, cannot rotate`);
        return this.getCurrentKey();
      }
      
      return this.rotateKey();
    }
    
    return this.getCurrentKey();
  }
};

// File to store server configurations
const SERVER_CONFIG_FILE = 'server-configs.json';

// Server configurations map
let serverConfigs = {};

// Global variables for tracking sales and timestamps
const lastProcessedSales = {
  // Collection address => Map of (saleId => timestamp)
  collections: new Map()
};
let lastCheckTime = null; // Timestamp of last check

// Max number of sale IDs to remember per collection (to prevent memory leaks)
const MAX_CACHE_SIZE_PER_COLLECTION = 50;

// Slash commands definition
const commands = [
  {
    name: 'track',
    description: 'Start tracking sales for a specific collection in a channel (Admin only)',
    options: [
      {
        name: 'channel',
        description: 'Channel to send notifications to',
        type: ApplicationCommandOptionType.Channel,
        required: true
      },
      {
        name: 'collection',
        description: 'Collection address to track',
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ]
  },
  {
    name: 'untrack',
    description: 'Stop tracking sales for a specific collection (Admin only)',
    options: [
      {
        name: 'collection',
        description: 'Collection address to stop tracking',
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ]
  },
  {
    name: 'list',
    description: 'Show all currently tracked collections (Admin only)'
  },
  {
    name: 'help',
    description: 'Show all available commands (Admin only)'
  },
  {
    name: 'checksales',
    description: 'Force an immediate check for new sales (Admin only)'
  },
  {
    name: 'debug-info',
    description: 'Show bot and channel configuration information for troubleshooting (Admin only)'
  },
  {
    name: 'refresh-images',
    description: 'Refresh all collection images (Admin only)'
  }
];

// Function to register slash commands
async function registerSlashCommands() {
  try {
    console.log('Started refreshing application (/) commands.');
    const rest = new REST({ version: '10' }).setToken(config.discordToken);
    await rest.put(
      Routes.applicationCommands(config.discordAppId),
      { body: commands }
    );
    console.log('Successfully reloaded application (/) commands.');
  } catch (error) {
    console.error('Error registering slash commands:', error);
  }
}

// Load server configurations from file
function loadServerConfigs() {
  try {
    if (fs.existsSync(SERVER_CONFIG_FILE)) {
      const data = fs.readFileSync(SERVER_CONFIG_FILE, 'utf8');
      serverConfigs = JSON.parse(data);
      console.log(`Loaded configurations for ${Object.keys(serverConfigs).length} servers`);
    } else {
      serverConfigs = {};
      console.log('No server configuration file found. Creating new configuration.');
      saveServerConfigs();
    }
  } catch (error) {
    console.error('Error loading server configurations:', error);
    serverConfigs = {};
  }
}

// Save server configurations to file
function saveServerConfigs() {
  try {
    fs.writeFileSync(SERVER_CONFIG_FILE, JSON.stringify(serverConfigs, null, 2), 'utf8');
    console.log('Server configurations saved successfully');
  } catch (error) {
    console.error('Error saving server configurations:', error);
  }
}

// Initialize server configuration if it doesn't exist
function initServerConfig(guildId) {
  if (!serverConfigs[guildId]) {
    serverConfigs[guildId] = {
      notificationChannelId: null,
      trackedCollections: {}
    };
    saveServerConfigs();
  } else if (Array.isArray(serverConfigs[guildId].trackedCollections)) {
    // Convert old format (array) to new format (object)
    const oldCollections = [...serverConfigs[guildId].trackedCollections];
    serverConfigs[guildId].trackedCollections = {};
    oldCollections.forEach(address => {
      serverConfigs[guildId].trackedCollections[address] = {
        address: address,
        source: 'Unknown',
        addedAt: new Date().toISOString()
      };
    });
    saveServerConfigs();
  }
  return serverConfigs[guildId];
}

// Function to fetch token metadata
async function fetchTokenMetadata(collectionAddress, tokenId) {
  if (!collectionAddress || !tokenId) return null;
  
  try {
    // Wait for rate limit before making request
    await apiKeyManager.waitForRateLimit();
    
    const url = `https://api-monad-testnet.reservoir.tools/tokens/v7?collection=${collectionAddress}&tokenId=${tokenId}`;
    
    const response = await axios.get(url, {
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      timeout: 5000
    });
    
    if (response.data && response.data.tokens && response.data.tokens.length > 0) {
      const token = response.data.tokens[0];
      
      return {
        name: token.token?.name || `NFT #${tokenId}`,
        image: cleanImageUrl(token.token?.image),
        collection: token.collection?.name || `Collection ${collectionAddress.substring(0, 6)}...`
      };
    }
    return null;
  } catch (error) {
    console.error(`Error fetching token metadata for ${collectionAddress} #${tokenId}:`, error.message);
    
    // Handle rate limit errors by rotating the API key
    if (error.response && (error.response.status === 429 || error.response.status === 403)) {
      console.log(`Rate limit hit fetching token metadata, rotating API key`);
      apiKeyManager.rotateKey();
    }
    
    return null;
  }
}

// Function to fetch collection information
async function fetchCollectionInfo(collectionAddress) {
  if (!collectionAddress) return null;
  
  try {
    // Wait for rate limit before making request
    await apiKeyManager.waitForRateLimit();
    
    const url = `https://api-monad-testnet.reservoir.tools/collections/v7?id=${collectionAddress}`;
    
    const response = await axios.get(url, {
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      timeout: 5000
    });
    
    if (response.data && response.data.collections && response.data.collections.length > 0) {
      const collection = response.data.collections[0];
      
      return {
        name: collection.name || `Collection ${collectionAddress.substring(0, 6)}...`,
        image: cleanImageUrl(collection.image),
        tokenCount: collection.tokenCount || 0,
        floorPrice: collection.floorAsk?.price?.amount?.native || 0
      };
    }
    return null;
  } catch (error) {
    console.error(`Error fetching collection info for ${collectionAddress}:`, error.message);
    
    // Handle rate limit errors by rotating the API key
    if (error.response && (error.response.status === 429 || error.response.status === 403)) {
      console.log(`Rate limit hit fetching collection info, rotating API key`);
      apiKeyManager.rotateKey();
    }
    
    return null;
  }
}

// Update fetchCollectionInfo to handle automatic key rotation
async function fetchCollectionInfo(collectionAddress) {
  if (!collectionAddress) {
    console.log('No collection address provided for fetchCollectionInfo');
    return null;
  }

  console.log(`Fetching collection info for: ${collectionAddress}`);
  
  // Special handling for Nad Name Service
  if (collectionAddress === '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308') {
    console.log('Using special image for Nad Name Service');
    return {
      name: 'Nad Name Service',
      image: 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg',
      description: 'Nad Name Service is the native naming protocol for Monad.'
    };
  }
  
  // Try Magic Eden API first
  try {
    console.log('Trying Magic Eden API first...');
    const url = `https://api-mainnet.magiceden.dev/v3/rtp/monad-testnet/collections/v7`;
    
    const response = await axios.get(url, {
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      params: {
        contract: collectionAddress,
      },
      timeout: 5000
    });

    if (response.status === 200 && response.data) {
      console.log(`Magic Eden API response:`, JSON.stringify(response.data).substring(0, 300));
      
      // Extract collection name and image from response
      const collection = response.data;
      
      // Check for different possible image field names in the API response
      const imageUrl = cleanImageUrl(
        collection.image || 
        collection.imageUrl || 
        collection.logo ||
        collection.logoURI ||
        null
      );
      
      if (collection.name) {
        console.log(`Found collection name from Magic Eden: ${collection.name}`);
        console.log(`Collection image: ${imageUrl || 'None found'}`);
        
        return {
          name: collection.name,
          image: imageUrl,
          description: collection.description || null
        };
      }
    }
    
    console.log(`No collection data found from Magic Eden for ${collectionAddress}`);
  } catch (error) {
    console.error(`Error fetching collection info from Magic Eden:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      
      // Check if this is a rate limit error and rotate keys if needed
      apiKeyManager.handleApiError(error);
    }
  }
  
  // Fallback to Reservoir API
  try {
    console.log('Falling back to Reservoir API...');
    const url = `https://api-monad-testnet.reservoir.tools/collections/v6`;
    
    const response = await axios.get(url, {
      params: {
        contract: collectionAddress,
      },
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      timeout: 5000
    });

    if (response.status === 200 && response.data && response.data.collections && response.data.collections.length > 0) {
      const collection = response.data.collections[0];
      console.log(`Found collection info from Reservoir: ${collection.name}`);
      
      // Log the structure to debug
      console.log('Collection data structure:', JSON.stringify(collection).substring(0, 300));
      
      const imageUrl = cleanImageUrl(collection.image || collection.collectionImage || null);
      
      return {
        name: collection.name || `Monad Collection ${collectionAddress.substring(0, 8)}...`,
        image: imageUrl,
        description: collection.description || null,
        floorPrice: collection.floorAsk?.price?.amount?.native || null,
        tokenCount: collection.tokenCount || null
      };
    } else {
      console.log(`No collection data found from Reservoir for ${collectionAddress}`);
      return {
        name: `Monad Collection ${collectionAddress.substring(0, 8)}...`
      };
    }
  } catch (error) {
    console.error(`Error fetching collection info from Reservoir:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      
      // Check if this is a rate limit error and rotate keys if needed
      apiKeyManager.handleApiError(error);
    }
    
    return {
      name: `Monad Collection ${collectionAddress.substring(0, 8)}...`
    };
  }
}

// Function to extract collection address from various formats
function extractCollectionAddress(input) {
  if (!input) return null;
  
  // Clean the input (trim whitespace, remove quotes)
  const cleanedInput = input.trim().replace(/^["']|["']$/g, '');
  
  // If it looks like a contract address (0x format)
  if (/^0x[0-9a-fA-F]{40}$/.test(cleanedInput)) {
    console.log(`Detected contract address format: ${cleanedInput}`);
    return {
      address: cleanedInput,
      source: 'Contract Address'
    };
  }
  
  // Handle address in URL format (from explorer, etc)
  const urlRegex = /0x[0-9a-fA-F]{40}/;
  const urlMatch = cleanedInput.match(urlRegex);
  if (urlMatch) {
    console.log(`Extracted address from URL: ${urlMatch[0]}`);
    return {
      address: urlMatch[0],
      source: 'URL'
    };
  }
  
  // If it doesn't match known patterns but isn't empty, assume it's a direct collection ID
  if (cleanedInput.length > 0) {
    console.log(`Using direct collection ID: ${cleanedInput}`);
    return {
      address: cleanedInput,
      source: 'Direct Collection ID'
    };
  }
  
  // If unable to extract, return null
  console.log(`Could not extract address from: ${input}`);
  return null;
}

// Modify createSaleEmbed function to work well with Reservoir data
function createSaleEmbed(sale) {
  // Get collection name, prioritizing different possible formats
  const collectionName = sale.collection?.name || 
                       sale.collection?.id || 
                       'Unknown Collection';
                       
  // Get token ID and name
  const tokenId = sale.token?.tokenId || 'Unknown';
  const tokenName = sale.token?.name || collectionName;
                
  // Get price from different possible formats
  let price = sale.price || 'Unknown';
  
  // If price is a string that's not "Unknown", convert to number and format nicely
  if (price !== 'Unknown' && !isNaN(parseFloat(price))) {
    // Convert to number first
    const num = parseFloat(price);
    // Use toLocaleString with proper options to handle decimal places
    price = num.toLocaleString('en-US', {
      minimumFractionDigits: 1,
      maximumFractionDigits: 4
    });
  }
  
  // Find and validate NFT image URL
  const imageUrl = cleanImageUrl(sale.token?.image);
  
  // Get transaction hash
  const txHash = sale.transaction || sale.txHash;
  const txUrl = `https://testnet.monadexplorer.com/tx/${txHash}`;
  
  // Use blue sidebar color (#007bff) like in the first image
  let embedColor = '#007bff';
  
  // Create the title that links to transaction - adding the alien emoji
  const title = 'üëΩ New Sale!';
  
  // Get seller and buyer addresses
  const seller = sale.seller || sale.fromAddress;
  const buyer = sale.buyer || sale.toAddress;
  
  // Create explorer URLs for seller and buyer addresses
  const sellerUrl = seller ? `https://testnet.monadexplorer.com/address/${seller}` : '';
  const buyerUrl = buyer ? `https://testnet.monadexplorer.com/address/${buyer}` : '';
  
  // Create the custom format showing NFT Name #tokenId has sold for X MON
  let saleDescription = `**${tokenName} #${tokenId} has sold for ${price} MON**`;
  
  // Add sale time if available
  }
  
  // Create the embed with the styling matching the screenshot
  let embed = new EmbedBuilder()
    .setColor(embedColor)
    .setTitle(title)
    .setURL(txUrl) // Make the title clickable with the transaction URL
    .setDescription(saleDescription)
    .setTimestamp();
  
  // Add seller and buyer fields with links
  if (seller) {
    embed.addFields({
      name: 'Seller',
      value: `[${shortenAddress(seller)}](${sellerUrl})`,
      inline: true
    });
  }
  
  if (buyer) {
    embed.addFields({
      name: 'Buyer',
      value: `[${shortenAddress(buyer)}](${buyerUrl})`,
      inline: true
    });
  }
  
  // Add token image if available and valid
  if (imageUrl) {
    embed.setImage(imageUrl);
    console.log(`Set image URL in embed: ${imageUrl}`);
  } else {
    console.log(`No valid image URL available for this sale`);
  }
  
  // Add footer with source and transaction hash
  embed.setFooter({ 
    text: `Made with Monalien Tech`,
    iconURL: 'https://cdn.discordapp.com/attachments/925536605738471425/1198969003852148797/A-27.png'
  });
  
  return embed;
}

// Helper function to shorten addresses
function shortenAddress(address) {
  if (!address) return 'Unknown';
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
}

// Clean up server configs - simplified 
function cleanServerConfigurations() {
  for (const [guildId, serverConfig] of Object.entries(serverConfigs)) {
    if (!serverConfig.trackedCollections) continue;
    
    const collections = serverConfig.trackedCollections;
    const newCollections = {};
    
    for (const [address, metadata] of Object.entries(collections)) {
      if (address.startsWith('0x')) {
        newCollections[address] = {
          ...metadata,
          address: address
        };
      }
    }
    
    serverConfig.trackedCollections = newCollections;
  }
  saveServerConfigs();
}

// Debug function to show cache status
function debugCacheStatus() {
  let totalEntries = 0;
  let collectionCount = lastProcessedSales.collections.size;
  
  for (const salesMap of lastProcessedSales.collections.values()) {
    totalEntries += salesMap.size;
  }
  
  console.log(`Sales cache status: ${totalEntries} total sales cached across ${collectionCount} collections`);
  
  // Log details for each collection
  for (const [collectionAddr, salesMap] of lastProcessedSales.collections.entries()) {
    console.log(`- Collection ${collectionAddr}: ${salesMap.size} sales cached`);
  }
}

// Function to fetch NFT sales from Reservoir API
async function fetchReservoirSales(collections) {
  if (!collections || collections.length === 0) return [];
  
  const detectedSales = [];
  const RESERVOIR_API_URL = "https://api-monad-testnet.reservoir.tools/collections/activity/v6";
  
  // Log the available API keys for debugging
  console.log(`Using ${apiKeyManager.reservoirKeys.length} API keys for Reservoir API requests`);
  
  try {
    for (const collectionAddress of collections) {
      console.log(`Checking activities for collection: ${collectionAddress}`);
      
      // Wait for rate limit before making request
      await apiKeyManager.waitForRateLimit();
      
      try {
        const response = await axios.get(RESERVOIR_API_URL, {
          headers: {
            'accept': '*/*',
            'x-api-key': apiKeyManager.getCurrentKey()
          },
          params: {
            collection: collectionAddress,
            limit: 20,
            types: 'sale'
          },
          timeout: 10000
        });
        
        if (!response.data?.activities) continue;

        const activities = response.data.activities;
        
        for (const activity of activities) {
          if (activity.type === 'sale') {
            const tokenId = activity.token?.tokenId || null;
            const tokenImage = cleanImageUrl(activity.token?.tokenImage);
            
            const sale = {
              id: activity.txHash || `reservoir_${Date.now()}`,
              collection: {
                id: collectionAddress,
                name: activity.collection?.collectionName || `Collection ${collectionAddress.substring(0, 6)}...`
              },
              price: activity.price?.amount?.native || 'Unknown',
              type: 'Sale',
              createdAt: activity.timestamp || new Date().toISOString(),
              buyer: activity.toAddress,
              seller: activity.fromAddress,
              token: {
                image: tokenImage,
                tokenId: tokenId || `unknown-${Date.now()}`,
                name: activity.token?.tokenName || null
              },
              transaction: activity.txHash
            };
            
            if ((tokenId && (!sale.token.image || sale.token.image === null)) || !sale.token.name) {
              try {
                const tokenMetadata = await fetchTokenMetadata(collectionAddress, tokenId);
                if (tokenMetadata) {
                  if (tokenMetadata.image && !sale.token.image) {
                    sale.token.image = tokenMetadata.image;
                  }
                  if (tokenMetadata.name && !sale.token.name) {
                    sale.token.name = tokenMetadata.name;
                  }
                }
              } catch (metadataError) {
                console.error(`Error fetching token metadata: ${metadataError.message}`);
              }
            }
            
            detectedSales.push(sale);
          }
        }
      } catch (collectionError) {
        console.error(`Error fetching sales for collection ${collectionAddress}:`, collectionError.message);
        
        // Handle rate limit errors by rotating the API key
        if (collectionError.response && (collectionError.response.status === 429 || collectionError.response.status === 403)) {
          console.log(`Rate limit hit for collection ${collectionAddress}, rotating API key`);
          apiKeyManager.rotateKey();
          
          // Add a small delay before continuing to the next collection
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    
    console.log(`Total sales detected: ${detectedSales.length}`);
    return detectedSales;
  } catch (error) {
    console.error("Error in fetchReservoirSales:", error.message);
    apiKeyManager.handleApiError(error);
    return [];
  }
}

// Updated processSales function to optionally skip notifications (for initialization)
async function processSales(sendNotifications = true) {
  try {
    console.log(`=================== PROCESSING SALES (Notifications: ${sendNotifications ? "ON" : "OFF"}) ===================`);
    debugCacheStatus();
    
    // Track if we found any sales
    let salesFound = false;
    let notificationsSent = 0;
    let newSalesFound = 0;
    
    // Clean up old cache entries (older than 1 hour)
    const now = Date.now();
    const ONE_HOUR = 60 * 60 * 1000;
    let cacheEntriesRemoved = 0;
    for (const [saleId, timestamp] of lastProcessedSales.processedSales.entries()) {
      if (now - timestamp > ONE_HOUR) {
        lastProcessedSales.processedSales.delete(saleId);
        cacheEntriesRemoved++;
      }
    }
    console.log(`Cleaned up ${cacheEntriesRemoved} old entries from sales cache`);
    
    // Process for each server with configuration
    const serverCount = Object.keys(serverConfigs).length;
    console.log(`Processing ${serverCount} Discord servers`);
    
    for (const [guildId, serverConfig] of Object.entries(serverConfigs)) {
      // Skip if no collections are being tracked or no notification channel is set
      if (!serverConfig.trackedCollections || 
          Object.keys(serverConfig.trackedCollections).length === 0 || 
          !serverConfig.notificationChannelId) {
        console.log(`‚è© Skipping guild ${guildId}: no collections tracked or no notification channel set`);
        continue;
      }

      // Get the guild and channel
      const guild = client.guilds.cache.get(guildId);
      if (!guild) {
        console.log(`Guild not found: ${guildId}`);
        continue;
      }

      const channel = guild.channels.cache.get(serverConfig.notificationChannelId);
      if (!channel) {
        console.log(`Notification channel not found for guild: ${guild.name}`);
        continue;
      }

      console.log(`Processing sales for guild: ${guild.name} (${guildId})`);
      console.log(`Total tracked collections: ${Object.keys(serverConfig.trackedCollections).length}`);
      
      // Check channel permissions
      const botPermissions = channel.permissionsFor(client.user);
      if (!botPermissions.has('SendMessages') || !botPermissions.has('EmbedLinks')) {
        console.log(`Bot lacks permissions in channel #${channel.name}: Cannot send messages or embed links`);
        continue;
      } else {
        console.log(`Bot has required permissions in channel #${channel.name}`);
      }

      try {
        // Extract collection addresses from tracked collections
        const collectionAddresses = Object.values(serverConfig.trackedCollections)
          .map(collection => typeof collection === 'string' ? collection : collection.address);

        // Process Reservoir sales
        console.log("Fetching sales via Reservoir API...");
        const reservoirSales = await fetchReservoirSales(collectionAddresses);
        console.log(`Detected ${reservoirSales.length} sales via Reservoir API`);
        
        // Sort sales by timestamp if available to process oldest first
        reservoirSales.sort((a, b) => {
          const timeA = new Date(a.createdAt).getTime() || 0;
          const timeB = new Date(b.createdAt).getTime() || 0;
          return timeA - timeB;
        });
        
        if (reservoirSales.length > 0) {
          salesFound = true;
          
          // Log all sales found
          console.log("Sales detected:");
          reservoirSales.forEach((sale, index) => {
            console.log(`Sale ${index + 1}/${reservoirSales.length}:`, 
              `collection=${sale.collection.id}`, 
              `saleId=${sale.id}`,
              `time=${sale.createdAt}`,
              `processed=${lastProcessedSales.processedSales.has(sale.id)}`);
          });
        } else {
          console.log("No sales detected via Reservoir API");
        }
        
        // Examine each sale
        for (const sale of reservoirSales) {
          // Get unique ID for sales
          const saleId = sale.id || `reservoir_${Date.now()}`;
          
          // Get timestamp from sale or use current time
          const timestamp = new Date(sale.createdAt).getTime() || Date.now();
          const saleTime = new Date(timestamp).toISOString();
          
          console.log(`Processing sale with ID: ${saleId} from ${saleTime}`);
          console.log(`Already processed? ${lastProcessedSales.processedSales.has(saleId)}`);
          
          // If we haven't processed this sale in the cache period
          if (saleId && !lastProcessedSales.processedSales.has(saleId)) {
            // Add to processed map with current timestamp
            lastProcessedSales.processedSales.set(saleId, Date.now());
            console.log(`Added sale ID to processed cache: ${saleId}`);
            console.log(`Cache size now: ${lastProcessedSales.processedSales.size}`);
            newSalesFound++;
            
            // Trim cache if needed
            if (lastProcessedSales.processedSales.size > MAX_CACHE_SIZE) {
              // Get oldest entry (first item)
              const oldestKey = Array.from(lastProcessedSales.processedSales.keys())[0];
              lastProcessedSales.processedSales.delete(oldestKey);
              console.log(`Trimmed oldest sale from cache: ${oldestKey}`);
              console.log(`Cache size after trim: ${lastProcessedSales.processedSales.size}`);
            }
            
            // Send notification to Discord if enabled
            if (sendNotifications) {
              console.log("üìù Creating embed for sale notification");
              const embed = createSaleEmbed(sale);
              
              const collectionName = sale.collection?.name || 
                                   sale.collection?.id || 
                                   'Unknown Collection';
              
              console.log(`SENDING NOTIFICATION for ${collectionName} sale (${saleId})`);
              try {
                await channel.send({ embeds: [embed] });
                console.log(`NOTIFICATION SENT SUCCESSFULLY for ${collectionName}!`);
                notificationsSent++;
              } catch (sendError) {
                console.error(`‚ùå ERROR SENDING NOTIFICATION: ${sendError.message}`);
                console.error("Is the bot allowed to post in this channel?");
                console.error("Full error:", sendError);
              }
            } else {
              console.log(`‚è© Skipping notification since notifications are disabled (${saleId})`);
            }
          } else {
            console.log(`‚è© Skipping sale ID ${saleId} - already processed or missing ID`);
          }
        }
      } catch (error) {
        console.error(`‚ùå Error processing sales for guild ${guild.name}:`, error.message);
        console.error("Full error:", error);
      }
    }
    
    if (!salesFound) {
      console.log("No sales found across all guilds");
    } else if (newSalesFound === 0) {
      console.log("No new sales found - all sales were already in cache");
    } else {
      console.log(`SALES PROCESSING COMPLETE - Found ${newSalesFound} new sales, sent ${notificationsSent} notifications`);
    }
  } catch (error) {
    console.error("‚ùå Error in processSales:", error.message);
    console.error("Full error:", error);
  }
}

// Check if user has admin permissions
function isAdmin(member) {
  return member.permissions.has(PermissionFlagsBits.Administrator);
}

// Function to update existing tracked collections with fresh info
async function updateCollectionInfo(guildId) {
  if (!serverConfigs[guildId] || !serverConfigs[guildId].trackedCollections) {
    return;
  }

  const collections = serverConfigs[guildId].trackedCollections;
  for (const [address, metadata] of Object.entries(collections)) {
    if (metadata.name === 'Unknown Collection' || !metadata.name) {
      try {
        console.log(`Updating info for collection ${address}`);
        // Just use our basic info format
        collections[address] = {
          ...metadata,
          address: address,
          name: `Monad Collection ${address.substring(0, 6)}...`,
          lastUpdated: new Date().toISOString()
        };
      } catch (error) {
        console.error(`Error updating collection info for ${address}:`, error.message);
      }
    }
  }
  saveServerConfigs();
}

// Function to validate an Ethereum collection address
function validateCollectionAddress(address) {
  if (!address) return false;
  
  // Basic format check (0x followed by 40 hex characters)
  const addressRegex = /^0x[0-9a-fA-F]{40}$/;
  const isValidFormat = addressRegex.test(address);
  
  if (!isValidFormat) {
    console.log(`Invalid address format: ${address}`);
    return false;
  }
  
  console.log(`Address format is valid: ${address}`);
  return true;
}

// Function to check if a guild is whitelisted
function isGuildWhitelisted(guildId) {
  // Log for debugging
  console.log(`Checking whitelist for guild: ${guildId}`);
  console.log(`Current whitelist: ${JSON.stringify(config.whitelistedGuilds)}`);
  
  // If whitelist is empty, allow all guilds (for backward compatibility)
  if (!config.whitelistedGuilds || config.whitelistedGuilds.length === 0) {
    console.log(`Whitelist is empty, allowing all guilds`);
    return true;
  }
  
  // Make sure we're comparing strings to strings
  const guildIdStr = String(guildId);
  const isWhitelisted = config.whitelistedGuilds.some(id => String(id) === guildIdStr);
  
  console.log(`Guild ${guildId} is ${isWhitelisted ? 'whitelisted' : 'NOT whitelisted'}`);
  return isWhitelisted;
}

// Handle slash commands
client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand() && !interaction.isButton()) return;
  
  try {
    // Check if the guild is whitelisted
    if (interaction.guildId && !isGuildWhitelisted(interaction.guildId)) {
      if (interaction.isCommand()) {
        await interaction.reply({ 
          content: 'This bot is not authorized to work in this server. Please contact the bot owner for access.', 
          ephemeral: true 
        });
      }
      return;
    }
    
    // Handle button interactions
    if (interaction.isButton()) {
      // Handle pagination buttons
      if (interaction.customId.startsWith('page_')) {
        const [_, currentPage, action] = interaction.customId.split('_');
        const guildId = interaction.guildId;
        
        if (!serverConfigs[guildId]) {
          await interaction.reply({ content: 'Server configuration not found.', ephemeral: true });
          return;
        }
        
        const trackedCollections = serverConfigs[guildId].trackedCollections;
        const newPage = action === 'next' ? parseInt(currentPage) + 1 : parseInt(currentPage) - 1;
        
        const { embed: embeds, currentPage: validatedPage, totalPages } = createCollectionListEmbed(
          trackedCollections,
          interaction.guild.name,
          newPage,
          5
        );
        
        const components = createCollectionListComponents(validatedPage, totalPages, trackedCollections);
        await interaction.update({ embeds: embeds, components });
        return;
      }
      
      // Handle individual untrack buttons
      if (interaction.customId.startsWith('untrack_')) {
        // Only admins can untrack collections
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to untrack collections.', ephemeral: true });
          return;
        }
        
        const [_, address, currentPage] = interaction.customId.split('_');
        const guildId = interaction.guildId;
        
        if (!serverConfigs[guildId] || !serverConfigs[guildId].trackedCollections[address]) {
          await interaction.reply({ content: 'That collection is no longer being tracked.', ephemeral: true });
          return;
        }
        
        const collectionName = serverConfigs[guildId].trackedCollections[address].name || 
                               `Collection ${address.substring(0, 8)}...`;
        
        // Delete the collection from tracking
        delete serverConfigs[guildId].trackedCollections[address];
        saveServerConfigs();
        
        // Refresh the list with the updated collections
        const trackedCollections = serverConfigs[guildId].trackedCollections;
        
        if (Object.keys(trackedCollections).length === 0) {
          // No more collections
          await interaction.update({ 
            content: `Successfully untracked **${collectionName}**. No more collections are being tracked.`,
            embeds: [], 
            components: [] 
          });
          return;
        }
        
        // Get updated embed and components
        const pageNum = parseInt(currentPage) || 1;
        const { embed: embeds, currentPage: validatedPage, totalPages } = createCollectionListEmbed(
          trackedCollections,
          interaction.guild.name,
          pageNum,
          5
        );
        
        const components = createCollectionListComponents(validatedPage, totalPages, trackedCollections);
        
        await interaction.update({
          content: `Successfully untracked **${collectionName}**. Updated tracking list:`,
          embeds: embeds,
          components
        });
        return;
      }
      
      if (interaction.customId === 'refresh_list') {
        // Only admins can refresh the list
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to refresh the list.', ephemeral: true });
          return;
        }
        
        // Rerun the list command logic
        const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
        if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
          await interaction.update({ content: 'No collections are currently being tracked.', embeds: [], components: [] });
          return;
        }
        
        try {
          // Use the paginated list display with individual untrack buttons
          const { embed: embeds, currentPage, totalPages } = createCollectionListEmbed(
            trackedCollections,
            interaction.guild.name,
            1,
            5
          );
          
          // Get components with untrack buttons for each collection
          const components = createCollectionListComponents(currentPage, totalPages, trackedCollections);
          
          await interaction.update({
            embeds: embeds,
            components: components
          });
        } catch (error) {
          console.error('Error refreshing tracked collections:', error);
          await interaction.update({ content: 'An error occurred while refreshing the list of tracked collections.', embeds: [], components: [] });
        }
        return;
      }
    }

    // Handle slash commands
    if (!interaction.isCommand()) return;
    if (!interaction.guildId) {
      await interaction.reply({ content: 'This command can only be used in a server.', ephemeral: true });
      return;
    }

    const guildId = interaction.guildId;
    const serverConfig = initServerConfig(guildId);

    const { commandName, options } = interaction;

    switch (commandName) {
      case 'track': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const channelOption = interaction.options.getChannel('channel');
          const collectionInput = interaction.options.getString('collection');
          
          if (!channelOption) {
            await interaction.editReply('Please provide a channel to send notifications to.');
            return;
          }
          
          if (!collectionInput) {
            await interaction.editReply('Please provide a collection address to track.');
            return;
          }
          
          // Check channel permissions
          const permissions = channelOption.permissionsFor(client.user);
          if (!permissions.has('SendMessages') || !permissions.has('EmbedLinks')) {
            await interaction.editReply(`I don't have permission to send messages and embeds in ${channelOption}. Please update channel permissions.`);
            return;
          }
          
          const collectionData = extractCollectionAddress(collectionInput);
          if (!collectionData || !collectionData.address) {
            await interaction.editReply('Invalid collection address format. Please provide a valid Ethereum address.');
            return;
          }
          
          const address = collectionData.address;
          
          if (!validateCollectionAddress(address)) {
            await interaction.editReply('Invalid collection address format. Please provide a valid Ethereum address.');
            return;
          }
          
          // Check if server config exists
          if (!serverConfigs[interaction.guildId]) {
            initServerConfig(interaction.guildId);
          }
          
          // Set notification channel to the specified channel
          serverConfigs[interaction.guildId].notificationChannelId = channelOption.id;
          
          // Check if collection is already tracked
          if (serverConfigs[interaction.guildId].trackedCollections[address]) {
            await interaction.editReply(`Collection ${address} is already being tracked.`);
            return;
          }
          
          // Send loading message while fetching collection info
          await interaction.editReply('üîç Fetching collection information, please wait...');
          
          // Try to get collection info first
          let collectionInfo = null;
          try {
            collectionInfo = await fetchCollectionInfo(address);
          } catch (infoError) {
            console.error('Error fetching collection info:', infoError);
          }
          
          // Use fetched name or default
          const collectionName = collectionInfo && collectionInfo.name ? 
            collectionInfo.name : `Monad Collection ${address.substring(0, 8)}...`;
          
          // Add collection to tracking list with info
          serverConfigs[interaction.guildId].trackedCollections[address] = {
            address: address,
            name: collectionName,
            addedAt: new Date().toISOString(),
            addedBy: interaction.user.id,
            source: collectionData.source || 'Contract Address'
          };
          
          // Add image if available
          if (collectionInfo && collectionInfo.image) {
            serverConfigs[interaction.guildId].trackedCollections[address].image = collectionInfo.image;
          }
          
          // Save config
          saveServerConfigs();
          
          // Immediately check this collection for sales
          console.log(`üîç Immediately checking the newly added collection ${address} for sales...`);
          try {
            const salesCount = await checkSingleCollection(address);
            console.log(`‚úÖ Initial check complete for ${address}: Found ${salesCount} existing sales to cache`);
          } catch (error) {
            console.error(`‚ùå Error in initial collection check:`, error.message);
          }
          
          // Create tracking confirmation embed with green sidebar that exactly matches the screenshot
          const trackingEmbed = new EmbedBuilder()
            .setColor('#4caf50') // Green color for the sidebar
            .setTitle(`Now Tracking: ${collectionName}`)
            .setDescription(`Successfully added to tracking list.`)
            .addFields(
              { name: 'Address', value: `${address}` },
              { name: 'Channel', value: `<#${channelOption.id}>`, inline: true },
              { name: 'Added By', value: `@${interaction.user.username}`, inline: true }
            )
            .addFields(
              { name: 'How to Untrack', value: `Use \`/untrack collection:${address}\`\nor click untrack in the \`/list\`.` }
            )
            .setTimestamp();
          
          // Add collection thumbnail if available
          if (collectionInfo && collectionInfo.image) {
            trackingEmbed.setThumbnail(collectionInfo.image);
          }
          
          await interaction.editReply({ content: null, embeds: [trackingEmbed] });
        } catch (error) {
          console.error('Error tracking collection:', error);
          await interaction.editReply('An error occurred while trying to track the collection.');
        }
        break;
      }
        
      case 'untrack': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        const untrackInput = options.getString('collection');
        if (!untrackInput) {
          await interaction.deferReply({ ephemeral: true });
          try {
            const { embed: embeds } = createCollectionListEmbed(
              serverConfig.trackedCollections,
              interaction.guild.name,
              1,
              5
            );
            await interaction.editReply({
              content: 'No collection given. Here are your tracked collections:',
              embeds: embeds,
              ephemeral: true
            });
          } catch (error) {
            console.error('Error in untrack command (no address):', error);
            await interaction.editReply({
              content: 'Error retrieving your tracked collections. Try again later.',
              ephemeral: true
            });
          }
          return;
        }
        // If user gave a number
        if (/^\d+$/.test(untrackInput.trim())) {
          const collectionNumber = parseInt(untrackInput.trim());
          const collectionEntries = Object.entries(serverConfig.trackedCollections);
          if (collectionNumber <= 0 || collectionNumber > collectionEntries.length) {
            await interaction.reply({
              content: `Invalid number. Must be between 1 and ${collectionEntries.length}.`,
              ephemeral: true
            });
            return;
          }
          const [addressToRemove, data] = collectionEntries[collectionNumber - 1];
          const cName = data.name || addressToRemove;
          delete serverConfig.trackedCollections[addressToRemove];
          saveServerConfigs();
          await interaction.reply({
            content: `No longer tracking collection #${collectionNumber}: ${cName}`,
            ephemeral: true
          });
          return;
        }
        
        // If user gave an address or partial name
        if (serverConfig.trackedCollections[untrackInput]) {
          const cName = serverConfig.trackedCollections[untrackInput].name || untrackInput;
          delete serverConfig.trackedCollections[untrackInput];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking: ${cName}`, ephemeral: true });
          return;
        }
        const collectionEntries = Object.entries(serverConfig.trackedCollections);
        const matchByName = collectionEntries.find(([_, data]) => {
          return data.name && data.name.toLowerCase().includes(untrackInput.toLowerCase());
        });
        if (matchByName) {
          const [addr, data] = matchByName;
          delete serverConfig.trackedCollections[addr];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking: ${data.name}`, ephemeral: true });
          return;
        }
        
        const untrackData = extractCollectionAddress(untrackInput);
        const untrackAddress = untrackData ? untrackData.address : untrackInput;
        if (serverConfig.trackedCollections[untrackAddress]) {
          const cName = serverConfig.trackedCollections[untrackAddress].name || untrackAddress;
          delete serverConfig.trackedCollections[untrackAddress];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking collection: ${cName}`, ephemeral: true });
        } else {
          await interaction.deferReply({ ephemeral: true });
          try {
            const { embed: embeds } = createCollectionListEmbed(
              serverConfig.trackedCollections,
              interaction.guild.name,
              1,
              5
            );
            await interaction.editReply({
              content: `Could not find a collection matching "${untrackInput}". Here are your tracked collections:`,
              embeds: embeds,
              ephemeral: true
            });
          } catch (error) {
            console.error('Error in untrack command (not found):', error);
            await interaction.editReply({
              content: `Could not find a matching collection. Use /list to see them.`,
              ephemeral: true
            });
          }
        }
        break;
      }
        
      case 'list': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        if (!serverConfigs[interaction.guildId]) {
          await interaction.reply({ content: 'No server configuration found. Please use /track to start tracking collections.', ephemeral: true });
          return;
        }
        
        const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
        if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
          await interaction.reply({ content: 'No collections are currently being tracked.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          // Use the paginated list display with individual untrack buttons
          const { embed: embeds, currentPage, totalPages } = createCollectionListEmbed(
            trackedCollections,
            interaction.guild.name,
            1,
            5
          );
          
          // Get components with untrack buttons for each collection
          const components = createCollectionListComponents(currentPage, totalPages, trackedCollections);
          
          await interaction.editReply({
            embeds: embeds,
            components: components
          });
        } catch (error) {
          console.error('Error displaying tracked collections:', error);
          await interaction.editReply('An error occurred while retrieving the list of tracked collections.');
        }
        break;
      }

      case 'checksales': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        try {
          // Don't clear the sales cache - instead just run the same check as the automated process
          // This ensures we only notify for new sales since the last check
          await interaction.editReply({ content: 'üîç Checking for new sales... Please wait...', ephemeral: true });
          
          // Force sales check for all configured servers
          const serverIds = Object.keys(serverConfigs);
          let successCount = 0;
          
          for (const serverId of serverIds) {
            const serverConfig = serverConfigs[serverId];
            if (!serverConfig || !serverConfig.trackedCollections || Object.keys(serverConfig.trackedCollections).length === 0) {
              continue;
            }
            
            try {
              await checkAndNotifySales(serverId);
              successCount++;
            } catch (checkError) {
              console.error(`Error checking sales for server ${serverId}:`, checkError);
            }
          }
          
          await interaction.editReply({ 
            content: `‚úÖ Sales check complete for ${successCount} servers! Check your notification channel for any new sale notifications.`, 
            ephemeral: true 
          });
        } catch (error) {
          console.error('Error checking sales:', error);
          await interaction.editReply({ content: 'An error occurred while checking for sales.', ephemeral: true });
        }
        break;
      }

      case 'help': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        // Get whitelist status
        const isWhitelisted = isGuildWhitelisted(interaction.guildId);
        
        const helpEmbed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('NFT Sales Bot Commands')
          .setDescription('Here are the commands you can use:')
          .addFields(
            { name: '/track <channel> <collection>', value: 'Track sales for a specific collection in the specified channel (Admin only)' },
            { name: '/untrack <collection>', value: 'Stop tracking a collection. You can supply the address or the list index (Admin only)' },
            { name: '/list', value: 'Show all currently tracked collections (with pagination) (Admin only)' },
            { name: '/checksales', value: 'Force an immediate check for new sales (Admin only)' },
            { name: '/refresh-images', value: 'Refresh collection images from APIs (Admin only)' },
            { name: '/help', value: 'Show this help message (Admin only)' }
          );
        
        // Add whitelist status field
        helpEmbed.addFields({
          name: 'Server Whitelist Status',
          value: isWhitelisted ? 
            '‚úÖ This server is whitelisted and has full access to the bot functionality.' : 
            '‚õî This server is NOT whitelisted. Bot functionality is restricted. Please contact the bot owner to request access.'
        });
        
        await interaction.reply({ embeds: [helpEmbed], ephemeral: true });
        break;
      }

      case 'debug-info': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const guildId = interaction.guildId;
          const serverConfig = serverConfigs[guildId] || { notificationChannelId: null, trackedCollections: {} };
          
          // Get whitelist status information
          const isWhitelisted = isGuildWhitelisted(guildId);
          const whitelistStatus = isWhitelisted ? 
            `‚úÖ This server is whitelisted` : 
            `‚õî This server is NOT whitelisted - Bot functionality is restricted`;
          
          // Get notifications channel info
          const notificationChannelId = serverConfig.notificationChannelId || serverConfig.notificationChannel;
          let channelInfo = 'Not set';
          
          if (notificationChannelId) {
            const channel = interaction.guild.channels.cache.get(notificationChannelId);
            if (channel) {
              channelInfo = `<#${channel.id}> (${channel.name})`;
              
              // Check permissions
              const perms = channel.permissionsFor(client.user);
              if (!perms.has('SendMessages') || !perms.has('EmbedLinks')) {
                channelInfo += ' ‚ö†Ô∏è BOT MISSING PERMISSIONS';
              } else {
                channelInfo += ' ‚úÖ Permissions OK';
              }
            } else {
              channelInfo = `ID: ${notificationChannelId} (CHANNEL NOT FOUND)`;
            }
          }
          
          // Get tracking status
          const collectionCount = Object.keys(serverConfig.trackedCollections || {}).length;
          const collectionList = Object.entries(serverConfig.trackedCollections || {})
            .map(([address, data]) => {
              const name = data.name || address;
              return `- ${name} (${address.substring(0, 8)}...)`;
            })
            .join('\n');
          
          // Get cache info
          const cacheSize = lastProcessedSales.processedSales.size;
          const lastCheckInfo = lastCheckTime ? lastCheckTime.toLocaleString() : 'Never';
          
          // Create a debug embed
          const debugEmbed = new EmbedBuilder()
            .setColor('#ff9900')
            .setTitle('Bot Debug Information')
            .setDescription(`Current configuration and status for this server`)
            .addFields(
              { name: 'Server ID', value: guildId, inline: true },
              { name: 'Whitelist Status', value: whitelistStatus, inline: true },
              { name: 'Configuration File', value: SERVER_CONFIG_FILE, inline: true },
              { name: 'Last Check Time', value: lastCheckInfo, inline: true },
              { name: 'Notification Channel', value: channelInfo, inline: false },
              { name: 'Collections Tracked', value: collectionCount > 0 ? 
                `${collectionCount} collections\n${collectionList}` : 'None', inline: false },
              { name: 'Sales Cache Size', value: `${cacheSize} entries`, inline: true },
              { name: 'Check Interval', value: `${config.refreshInterval / 1000} seconds`, inline: true }
            )
            .setFooter({ text: `Bot Version: 1.4.0` })
            .setTimestamp();
            
          await interaction.editReply({ embeds: [debugEmbed], ephemeral: true });
          
        } catch (error) {
          console.error('Error in debug-info command:', error);
          await interaction.editReply({
            content: `Error generating debug info: ${error.message}`,
            ephemeral: true
          });
        }
        break;
      }

      case 'refresh-images': {
        // Admin check for all commands
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
          if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
            await interaction.editReply('No collections are currently being tracked.');
            return;
          }
          
          let updatedCount = 0;
          let failedCount = 0;
          const collectionAddresses = Object.keys(trackedCollections);
          
          await interaction.editReply(`üîÑ Refreshing images for ${collectionAddresses.length} collections...`);
          
          for (const address of collectionAddresses) {
            try {
              // Try to get fresh collection info
              const collectionInfo = await fetchCollectionInfo(address);
              
              if (collectionInfo && collectionInfo.image) {
                // Update the collection image if one was found
                trackedCollections[address].image = collectionInfo.image;
                updatedCount++;
              } else {
                // If no image found from APIs, try a special case for known collections
                if (address === '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308') {
                  trackedCollections[address].image = 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg'; // Twitter image for NNS
                  updatedCount++;
                } else {
                  failedCount++;
                }
              }
            } catch (error) {
              console.error(`Error refreshing image for collection ${address}:`, error);
              failedCount++;
            }
          }
          
          // Save updated config
          saveServerConfigs();
          
          // Create update confirmation embed
          const refreshEmbed = new EmbedBuilder()
            .setColor('#4caf50')
            .setTitle('Collection Images Refreshed')
            .setDescription(`Successfully refreshed images for ${updatedCount} collections.${failedCount > 0 ? `\n‚ö†Ô∏è Failed to refresh ${failedCount} collections.` : ''}`)
            .setTimestamp();
          
          await interaction.editReply({ content: null, embeds: [refreshEmbed] });
        } catch (error) {
          console.error('Error refreshing collection images:', error);
          await interaction.editReply('An error occurred while trying to refresh collection images.');
        }
        break;
      }
    }
  } catch (error) {
    console.error('Error handling interaction:', error);
    // Try to respond if we haven't already
    try {
      if (interaction.deferred) {
        await interaction.editReply({
          content: 'An error occurred while processing your command. Please try again.',
          ephemeral: true
        });
      } else if (!interaction.replied) {
        await interaction.reply({
          content: 'An error occurred while processing your command. Please try again.',
          ephemeral: true
        });
      }
    } catch (replyError) {
      console.error('Failed to send error response:', replyError);
    }
  }
});

// Basic function to create a paginated embed for tracked collections
function createCollectionListEmbed(collections, guildName, page = 1, itemsPerPage = 5) {
  const collectionEntries = Object.entries(collections);
  const totalCollections = collectionEntries.length;
  const totalPages = Math.ceil(totalCollections / itemsPerPage);
  
  page = Math.max(1, Math.min(page, totalPages || 1));
  const startIndex = (page - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage, totalCollections);
  const pageItems = collectionEntries.slice(startIndex, endIndex);

  // Create a header embed
  const headerEmbed = new EmbedBuilder()
    .setColor('#2196f3') // Blue color for the sidebar
    .setTitle(`Tracked Collections`)
    .setDescription(
      totalCollections === 0
        ? 'No collections being tracked.'
        : `This server is tracking ${totalCollections} collections.`
    );
  
  if (totalPages > 1) {
    headerEmbed.setFooter({ text: `Page ${page}/${totalPages}` });
  } else {
    headerEmbed.setFooter({ text: `Today at ${new Date().toLocaleTimeString('en-US', {hour: '2-digit', minute:'2-digit'})}` });
  }

  // Create an array of embeds, starting with the header
  const embeds = [headerEmbed];
  
  // Create an embed for each collection
  let collectionNum = startIndex + 1;
  pageItems.forEach(([addr, collection]) => {
    // Get collection name, fallback to address format if not available
    const displayName = collection.name || `Collection ${addr.substring(0, 8)}...`;
    
    console.log(`Debug - Collection ${displayName} (${addr}):`, JSON.stringify(collection));
    
    // Format added by with @ mention if user ID is available
    const addedBy = collection.addedBy ? `@${getUsernameFromId(collection.addedBy) || 'user'}` : 'Unknown';
    
    // Format added date nicely
    const addedDate = collection.addedAt 
      ? new Date(collection.addedAt).toLocaleString('en-US', {
          month: 'numeric', 
          day: 'numeric', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        })
      : 'Unknown';
    
    // Create a collection embed
    const collectionEmbed = new EmbedBuilder()
      .setColor('#2196f3')
      .setTitle(`${collectionNum}. ${displayName}`)
      .setDescription(`**Address**: ${addr}\n**Added by**: ${addedBy}\n**Added on**: ${addedDate}`)
      .setTimestamp();
    
    // Add image if available - make sure it's a valid URL
    if (collection.image && typeof collection.image === 'string' && collection.image.trim() !== '') {
      console.log(`Setting image for ${displayName}: ${collection.image}`);
      
      try {
        // Sometimes special characters in URLs can cause issues, so ensure it's properly encoded
        const imageUrl = collection.image.includes('https://i.imgur.com') 
          ? collection.image  // If it's already an imgur URL, use it as is
          : encodeURI(collection.image);  // Otherwise encode it
          
        collectionEmbed.setImage(imageUrl);
        console.log(`Successfully set image URL: ${imageUrl}`);
      } catch (error) {
        console.error(`Error setting image for ${displayName}:`, error.message);
      }
    } else {
      console.log(`No image available for ${displayName}`);
    }
    
    embeds.push(collectionEmbed);
    collectionNum++;
  });
  
  return { embed: embeds, currentPage: page, totalPages };
}

// Helper function to get username from ID (mock implementation)
function getUsernameFromId(userId) {
  const user = client.users.cache.get(userId);
  return user ? user.username : null;
}

// Button row(s) for collection list pagination + untrack
function createCollectionListComponents(currentPage, totalPages, collections) {
  const components = [];
  // page nav
  if (totalPages > 1) {
    const navRow = new ActionRowBuilder();
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_prev`)
        .setLabel('Previous')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚¨ÖÔ∏è')
        .setDisabled(currentPage <= 1)
    );
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_indicator`)
        .setLabel(`Page ${currentPage}/${totalPages}`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(true)
    );
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_next`)
        .setLabel('Next')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚û°Ô∏è')
        .setDisabled(currentPage >= totalPages)
    );
    components.push(navRow);
  }

  // untrack row (one button per collection on current page)
  const collectionEntries = Object.entries(collections);
  const startIndex = (currentPage - 1) * 5;
  const endIndex = Math.min(startIndex + 5, collectionEntries.length);
  const pageItems = collectionEntries.slice(startIndex, endIndex);
  
  if (pageItems.length > 0) {
    const actionRow = new ActionRowBuilder();
    pageItems.forEach(([addr, data], i) => {
      const index = startIndex + i + 1;
      let displayLabel = data.name || `Collection ${index}`;
      if (displayLabel.length > 20) {
        displayLabel = displayLabel.substring(0, 20) + '‚Ä¶';
      }
      actionRow.addComponents(
        new ButtonBuilder()
          .setCustomId(`untrack_${addr}_${currentPage}`)
          .setLabel(displayLabel)
          .setStyle(ButtonStyle.Danger)
          .setEmoji('üóëÔ∏è')
      );
    });
    components.push(actionRow);
  }
  return components;
}

// Bot ready event
client.once('ready', async () => {
  console.log(`=== Monad NFT Sales Bot v1.4.0 ===`);
  console.log(`Bot logged in as ${client.user.tag}`);
  
  // Check whitelist configuration
  validateWhitelist();
  
  // Load server configurations first
  loadServerConfigs();
  
  // Register slash commands
  await registerSlashCommands();
  
  // Log whitelist status
  if (config.whitelistedGuilds && config.whitelistedGuilds.length > 0) {
    console.log(`üîí Whitelist enabled - Bot will only operate in ${config.whitelistedGuilds.length} whitelisted servers`);
    console.log(`Whitelisted guild IDs: ${config.whitelistedGuilds.join(', ')}`);
  } else {
    console.log(`‚ö†Ô∏è Whitelist not configured - Bot will operate in any server it joins`);
  }
  
  // Initialize and start the sales tracker
  await initializeBot();
  
  console.log('‚è±Ô∏è Starting periodic checks for sales every', 
    (config.refreshInterval / 1000), 'seconds');
  
  // Start the periodic check for sales and store the interval
  global.salesCheckInterval = setInterval(async () => {
    try {
      console.log('üîÑ Running periodic sales check');
      for (const serverId in serverConfigs) {
        await checkAndNotifySales(serverId);
      }
    } catch (error) {
      console.error('‚ùå Error in sales check interval:', error);
    }
  }, config.refreshInterval);
  
  // Set up periodic maintenance tasks
  setInterval(() => {
    try {
      console.log('üîÑ Running periodic maintenance tasks...');
      
      // Reset API key rate limit tracking
      apiKeyManager.resetRateLimits();
      console.log('‚úÖ Reset API rate limit tracking');
      
      // Reset API key rotation
      apiKeyManager.currentKeyIndex = 0;
      apiKeyManager.lastQueryTimes = {};
      console.log('‚úÖ Reset API key rotation');
      
      // Clean up server configurations
      cleanServerConfigurations();
      console.log('‚úÖ Cleaned server configurations');
      
      // Clean up sales cache
      const now = Date.now();
      const ONE_HOUR = 60 * 60 * 1000;
      let cacheEntriesRemoved = 0;
      
      for (const [saleId, timestamp] of lastProcessedSales.processedSales.entries()) {
        if (now - timestamp > ONE_HOUR) {
          lastProcessedSales.processedSales.delete(saleId);
          cacheEntriesRemoved++;
        }
      }
      console.log(`‚úÖ Cleaned up ${cacheEntriesRemoved} old entries from sales cache`);
      
    } catch (error) {
      console.error('‚ùå Error in maintenance tasks:', error);
    }
  }, 30 * 60 * 1000); // Run every 30 minutes
  
  console.log('‚úÖ Bot setup complete and ready to notify about NFT sales');
});

// Load server configurations
loadServerConfigs();

// Register slash commands 
registerSlashCommands();

// Login to Discord
client.login(config.discordToken);

// Function to periodically check for collections sales 
async function checkAndNotifySales(serverId) {
  // Check if the server is whitelisted
  if (!isGuildWhitelisted(serverId)) {
    console.log(`Skipping guild ${serverId} - not in whitelist`);
    return;
  }
  
  const serverConfig = serverConfigs[serverId];
  if (!serverConfig) {
    console.log(`No configuration for server ${serverId}`);
    return;
  }
  
  // Handle both property names for backward compatibility
  const notificationChannelId = serverConfig.notificationChannelId || serverConfig.notificationChannel;
  
  if (!notificationChannelId) {
    console.log(`No notification channel for server ${serverId}`);
    return;
  }

  try {
    const guild = client.guilds.cache.get(serverId);
    if (!guild) {
      console.log(`Guild ${serverId} not found - bot may not be in this server`);
      return;
    }

    const channel = guild.channels.cache.get(notificationChannelId);
    if (!channel) {
      console.log(`Channel ${notificationChannelId} not found in guild ${serverId} - it may have been deleted`);
      return;
    }

    // Check channel permissions
    const perms = channel.permissionsFor(client.user);
    if (!perms || !perms.has('SendMessages') || !perms.has('EmbedLinks')) {
      console.error(`Bot doesn't have permission to send messages to channel #${channel.name} in ${guild.name}`);
      return;
    }

    console.log(`Running checkAndNotifySales for ${guild.name}`);
    
    // Get collection addresses for this server
    const collectionAddresses = [];
    
    // Extract from tracked collections - handle both formats
    if (serverConfig.trackedCollections) {
      for (const key in serverConfig.trackedCollections) {
        const collection = serverConfig.trackedCollections[key];
        // Handle both string and object formats
        const address = typeof collection === 'string' ? collection : collection.address;
        if (address) collectionAddresses.push(address);
      }
    }
      
    console.log(`Checking ${collectionAddresses.length} collections for ${guild.name}`);

    if (collectionAddresses.length === 0) {
      console.log(`No collections to check for server ${serverId}`);
      return;
    }

    // Process Reservoir sales
    console.log("Fetching sales via Reservoir API...");
    const reservoirSales = await fetchReservoirSales(collectionAddresses);
    console.log(`Detected ${reservoirSales.length} sales via Reservoir API`);
    
    // If no sales were detected, exit
    if (reservoirSales.length === 0) {
      console.log("No sales detected for these collections");
      return;
    }

    // Track statistics for logging
    let processedCount = 0;
    let newSalesCount = 0;
    let successCount = 0;
    let errorCount = 0;

    // Notify about each sale
    for (const sale of reservoirSales) {
      processedCount++;
      const saleId = sale.id || `reservoir_${Date.now()}`;
      
      // Get collection address
      const collectionAddr = sale.collection.id;
      
      const collectionName = sale.collection?.name || 
                         sale.collection?.id || 
                         'Unknown Collection';
      
      // Check if we've already notified about this sale
      if (hasSaleBeenProcessed(collectionAddr, saleId)) {
        console.log(`üîÑ Already processed sale ${saleId} (${collectionName}), skipping`);
        continue;
      }

      // We have a new sale to notify about
      newSalesCount++;
      console.log(`üîî NEW SALE DETECTED for ${collectionName} (${saleId})`);

      try {
        // Create the embed
        const embed = createSaleEmbed(sale);
        
        // Send the notification
        console.log(`üì§ Sending notification to #${channel.name} in ${guild.name}`);
        await channel.send({ embeds: [embed] });
        console.log(`‚úÖ NOTIFICATION SENT SUCCESSFULLY for ${collectionName}!`);
        
        // Mark as notified in collection cache
        addSaleToProcessed(collectionAddr, saleId);
        console.log(`üìã Added sale ${saleId} to collection cache for ${collectionAddr}`);
        successCount++;
      } catch (sendError) {
        errorCount++;
        console.error(`‚ùå ERROR SENDING NOTIFICATION: ${sendError.message}`);
        console.error(`Channel: #${channel.name}, Guild: ${guild.name}, Sale ID: ${saleId}`);
        
        // Still add to cache to avoid repeatedly trying to send failed notifications
        addSaleToProcessed(collectionAddr, saleId);
      }
    }
    
    // Log summary of operation
    console.log(`üìä SUMMARY for ${guild.name}: Processed ${processedCount} sales, ${newSalesCount} new, ${successCount} notifications sent, ${errorCount} errors`);
  } catch (error) {
    console.error(`‚ùå Error checking and notifying sales for server ${serverId}:`, error.message);
    console.error(error.stack);
  }
}

// Function to send a test notification
async function testNotification(guildId) {
  try {
    // Check if the server is whitelisted
    if (!isGuildWhitelisted(guildId)) {
      console.log(`‚ö†Ô∏è Cannot send test notification - Guild ${guildId} is not whitelisted`);
      return false;
    }
    
    // Check if the server exists in the config
    if (!serverConfigs[guildId]) {
      console.log(`‚ö†Ô∏è No configuration found for guild ${guildId}`);
      return false;
    }

    // Handle both property names for backward compatibility
    const channelId = serverConfigs[guildId].notificationChannelId || serverConfigs[guildId].notificationChannel;
    
    if (!channelId) {
      console.log(`‚ö†Ô∏è No notification channel configured for guild ${guildId}`);
      return false;
    }

    // Get the guild and channel
    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
      console.log(`‚ùå Guild ${guildId} not found`);
      return false;
    }

    const channel = guild.channels.cache.get(channelId);
    if (!channel) {
      console.log(`‚ùå Channel ${channelId} not found in guild ${guildId}`);
      return false;
    }

    // Check channel permissions
    const permissions = channel.permissionsFor(client.user);
    if (!permissions.has('SendMessages') || !permissions.has('EmbedLinks')) {
      console.log(`‚ùå Bot doesn't have permission to send messages or embeds in ${channel.name}`);
      return false;
    }

    // Create a test sale object matching the screenshot
    const testSale = {
      id: `test_${Date.now()}`,
      type: 'Sale',
      createdAt: new Date().toISOString(),
      collection: {
        id: '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308',
        name: 'Nad Name Service'
      },
      price: '0.2',
      token: {
        tokenId: '456367',
        name: 'Nad Name', // Just the name without "Service" to make it clearer for the "#token" format
        // Use the reliable Twitter image for NNS
        image: 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg'
      },
      buyer: '0xf751616eb8f4bec5d246922b7c5dd939b9f9c984',
      seller: '0x335b9864520a2f28f1a510aebcb66daca6b1c0e4',
      transaction: '0x2c8c32e5ef4a58d95a70a4e1bf4dd21e15e3cb2cb3b76c8a56ab3c79eaa3abf2'
    };

    console.log(`üîç Creating test notification for: ${testSale.collection.name}`);

    // Create the embed for the notification
    const embed = createSaleEmbed(testSale);
    console.log('üìù Test embed created');

    // Send the notification - direct send to bypass notification system
    console.log(`üì§ Sending test notification to ${guild.name} #${channel.name}`);
    await channel.send({ embeds: [embed] });
    console.log(`‚úÖ Test notification sent successfully to ${guild.name}`);
    return true;
  } catch (error) {
    console.error(`‚ùå Error sending test notification:`, error);
    return false;
  }
}

/**
 * Initialize the bot and set up sales tracking
 */
async function initializeBot() {
  console.log('üöÄ Initializing bot and setting up sales tracker...');
  
  // Initialize the lastCheckTime to track when we last checked for sales
  // Set to 5 minutes ago instead of current time to catch recent sales
  lastCheckTime = new Date(Date.now() - 5 * 60 * 1000);
  
  console.log('‚è±Ô∏è Initializing with time:', lastCheckTime.toISOString());
  
  // Clear the sales cache completely - don't load old cache
  lastProcessedSales.collections.clear();
  console.log('üßπ Cleared sales cache for fresh start');
  
  // Make the initial sales check run after a delay to give the bot time to connect
  // But do NOT send notifications for initial sales - only cache them
  setTimeout(async () => {
    console.log('üîç Running initial sales check for all servers (NOTIFICATION DISABLED - ONLY CACHING)...');
    
    // First, gather all collection addresses across all servers
    const allCollectionAddresses = new Set();
    
    for (const serverId in serverConfigs) {
      // Only check whitelisted servers
      if (!isGuildWhitelisted(serverId)) {
        console.log(`‚è© Skipping initial check for non-whitelisted guild: ${serverId}`);
        continue;
      }
      
      try {
        const serverConfig = serverConfigs[serverId];
        if (!serverConfig || !serverConfig.trackedCollections) continue;
        
        // Extract collection addresses
        for (const key in serverConfig.trackedCollections) {
          const collection = serverConfig.trackedCollections[key];
          const address = typeof collection === 'string' ? collection : collection.address;
          if (address) allCollectionAddresses.add(address);
        }
      } catch (error) {
        console.error(`‚ùå Error collecting addresses for server ${serverId}:`, error);
      }
    }
    
    // Now fetch sales for all collections at once, but don't send notifications
    console.log(`üîÑ Caching existing sales for ${allCollectionAddresses.size} collections during initialization...`);
    
    if (allCollectionAddresses.size === 0) {
      console.log('No collections to check, skipping initial cache');
      return;
    }
    
    try {
      // Use fetchReservoirSales directly
      const initialSales = await fetchReservoirSales([...allCollectionAddresses]);
      console.log(`üì¶ Found ${initialSales.length} existing sales to cache`);
      
      // Add all these sales to the cache without notifications
      let newCacheEntries = 0;
      for (const sale of initialSales) {
        const saleId = sale.id || `reservoir_${Date.now()}`;
        const collectionAddr = sale.collection.id;
        
        // Always add to cache during initialization
        addSaleToProcessed(collectionAddr, saleId);
        newCacheEntries++;
      }
      
      console.log(`‚úÖ Added ${newCacheEntries} new entries to sales cache during initialization`);
      console.log(`‚úÖ Initial sales caching complete - bot is now ready to monitor for NEW sales only`);
      console.log(`üö´ No notifications were sent for existing ${newCacheEntries} sales`);
    } catch (error) {
      console.error('‚ùå Error during initial sales caching:', error);
    }
  }, 10000); // 10 second delay
  
  console.log('‚úÖ Bot initialized and ready to monitor for new sales');
}

/**
 * Check a single collection for sales and add to cache (but don't notify)
 * @param {string} collectionAddress The collection address to check
 * @returns {Promise<number>} The number of sales found and cached
 */
async function checkSingleCollection(collectionAddress) {
  if (!collectionAddress) return 0;
  
  console.log(`üîç Checking single collection: ${collectionAddress}`);
  try {
    // Fetch sales for just this collection
    const sales = await fetchReservoirSales([collectionAddress]);
    
    if (sales.length > 0) {
      console.log(`üìä Found ${sales.length} existing sales for collection ${collectionAddress}`);
      
      // Add existing sales to cache to avoid immediate notifications for old sales
      for (const sale of sales) {
        const saleId = sale.id || `reservoir_${Date.now()}`;
        if (!lastProcessedSales.processedSales.has(saleId)) {
          lastProcessedSales.processedSales.set(saleId, Date.now());
          console.log(`üìã Added sale ${saleId} to processed cache`);
        }
      }
    } else {
      console.log(`üìä No existing sales found for collection ${collectionAddress}`);
    }
    
    // Log and return the count
    return sales.length;
  } catch (error) {
    console.error(`‚ùå Error checking single collection for sales:`, error.message);
    return 0;
  }
}

// Fix invalid image URL formats throughout the app
function cleanImageUrl(url) {
  if (!url) return null;
  
  try {
    // Remove content type information if present
    if (url.includes(';')) {
      url = url.split(';')[0];
    }
    
    // Fix broken URLs with .svg+xml format
    url = url.replace('.svg+xml', '.svg');
    
    // For Reservoir URLs, ensure we have a valid image format
    if (url.includes('reservoir.tools') && !url.match(/\.(jpeg|jpg|gif|png|svg|webp)($|\?)/i)) {
      url += (url.includes('?') ? '&' : '?') + 'format=png';
    }
    
    // Try to validate the URL
    new URL(url);
    
    return url;
  } catch (error) {
    console.error(`Invalid image URL: ${url}`, error.message);
    return null;
  }
}

// Add this function near the other helper functions
// Has sale been processed?
function hasSaleBeenProcessed(collectionAddr, saleId) {
  if (!lastProcessedSales.collections.has(collectionAddr)) {
    return false;
  }
  
  const salesMap = lastProcessedSales.collections.get(collectionAddr);
  return salesMap.has(saleId);
}

// Add sale to processed cache 
function addSaleToProcessed(collectionAddr, saleId) {
  // Create map for collection if it doesn't exist
  if (!lastProcessedSales.collections.has(collectionAddr)) {
    lastProcessedSales.collections.set(collectionAddr, new Map());
  }
  
  const salesMap = lastProcessedSales.collections.get(collectionAddr);
  
  // Add sale ID with current timestamp
  salesMap.set(saleId, Date.now());
  
  // Trim if needed
  if (salesMap.size > MAX_CACHE_SIZE_PER_COLLECTION) {
    // Get oldest entry (first item)
    const oldestKey = Array.from(salesMap.keys())[0];
    salesMap.delete(oldestKey);
  }
  
  return true;
}

// Validate whitelist configuration
function validateWhitelist() {
  console.log(`\n======= WHITELIST CONFIGURATION =======`);
  
  if (!process.env.WHITELISTED_GUILDS || process.env.WHITELISTED_GUILDS.trim() === '') {
    console.log(`‚ö†Ô∏è WHITELIST NOT CONFIGURED: Bot will work in ALL servers it joins`);
    console.log(`To enable whitelist, add guild IDs to WHITELISTED_GUILDS in .env file`);
  } else {
    console.log(`‚úÖ WHITELIST ENABLED: ${config.whitelistedGuilds.length} servers authorized`);
    console.log(`Whitelisted server IDs: ${config.whitelistedGuilds.join(', ')}`);
    
    // Check if any current servers are not whitelisted
    const nonWhitelisted = client.guilds.cache.filter(guild => !isGuildWhitelisted(guild.id));
    if (nonWhitelisted.size > 0) {
      console.log(`\n‚ö†Ô∏è BOT IS IN ${nonWhitelisted.size} NON-WHITELISTED SERVERS:`);
      nonWhitelisted.forEach(guild => {
        console.log(`- "${guild.name}" (ID: ${guild.id}) - commands and notifications will be DISABLED`);
      });
    }
  }
  console.log(`========================================\n`);
}
