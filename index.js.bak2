require('dotenv').config();
const {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ApplicationCommandOptionType,
  REST,
  Routes,
  StringSelectMenuBuilder
} = require('discord.js');
const axios = require('axios');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');

// Discord client setup
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// Configuration
const config = {
  discordToken: process.env.DISCORD_TOKEN,
  discordAppId: process.env.DISCORD_APP_ID,
  refreshInterval: parseInt(process.env.REFRESH_INTERVAL) || 60000, // Default to 1 minute
};

// API key management
const apiKeyManager = {
  reservoirKeys: [
    'c65ab60c-61a5-5e1c-bb44-d4cc4c0af8a0', // Main key
    '2nd-reservoir-api-key-goes-here',       // Backup key 1
    '3rd-reservoir-api-key-goes-here'        // Backup key 2
  ],
  currentKeyIndex: 0,
  rateLimitDetected: {},
  
  getCurrentKey() {
    return this.reservoirKeys[this.currentKeyIndex];
  },
  
  resetRateLimits() {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    
    // Clear rate limit detections older than 1 hour
    for (const key in this.rateLimitDetected) {
      if (this.rateLimitDetected[key] < oneHourAgo) {
        console.log(`🔄 Resetting rate limit status for key ${this.maskApiKey(key)}`);
        delete this.rateLimitDetected[key];
      }
    }
  },
  
  maskApiKey(key) {
    if (!key || key.length < 8) return '****';
    return `${key.substring(0, 4)}...${key.substring(key.length - 4)}`;
  },
  
  rotateKey() {
    const previousKey = this.getCurrentKey();
    const previousIndex = this.currentKeyIndex;
    const now = Date.now();
    
    // Mark current key as rate limited
    this.rateLimitDetected[previousKey] = now;
    
    // Try to find a key that hasn't been rate limited in the last 5 minutes
    const fiveMinutesAgo = now - (5 * 60 * 1000);
    let foundUsableKey = false;
    
    for (let i = 0; i < this.reservoirKeys.length; i++) {
      // Skip to next key index
      this.currentKeyIndex = (this.currentKeyIndex + 1) % this.reservoirKeys.length;
      const nextKey = this.getCurrentKey();
      
      // Check if this key has hit rate limits recently
      if (!this.rateLimitDetected[nextKey] || this.rateLimitDetected[nextKey] < fiveMinutesAgo) {
        foundUsableKey = true;
        console.log(`🔄 Rotating from API key ${this.maskApiKey(previousKey)} to ${this.maskApiKey(nextKey)}`);
        break;
      }
    }
    
    if (!foundUsableKey) {
      // If all keys are rate limited, just use the next one anyway
      console.log(`⚠️ All API keys are rate limited, using key ${this.maskApiKey(this.getCurrentKey())}`);
    }
    
    // If we're back to the same key, log that all keys are rate limited
    if (previousIndex === this.currentKeyIndex) {
      console.log(`⚠️ Tried all API keys, all are rate limited. Using original key again.`);
    }
    
    return this.getCurrentKey();
  },
  
  handleApiError(error) {
    // Check if this is a rate limit error (429 Too Many Requests or 403 Forbidden)
    if (error.response && (error.response.status === 429 || error.response.status === 403)) {
      console.log(`⚠️ Rate limit detected for API key ${this.maskApiKey(this.getCurrentKey())}`);
      return this.rotateKey();
    }
    
    // Not a rate limit error
    return this.getCurrentKey();
  }
};

// File to store server configurations
const SERVER_CONFIG_FILE = 'server-configs.json';

// Server configurations map
let serverConfigs = {};

// Global variables for tracking sales and timestamps
const lastProcessedSales = {
  processedSales: new Map() // saleId => timestamp
};
let lastCheckTime = null; // Timestamp of last check

// Max number of sale IDs to remember (to prevent memory leaks)
const MAX_CACHE_SIZE = 100;

// Slash commands definition
const commands = [
  {
    name: 'track',
    description: 'Start tracking sales for a specific collection in a channel (Admin only)',
    options: [
      {
        name: 'channel',
        description: 'Channel to send notifications to',
        type: ApplicationCommandOptionType.Channel,
        required: true
      },
      {
        name: 'collection',
        description: 'Collection address to track',
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ]
  },
  {
    name: 'untrack',
    description: 'Stop tracking sales for a specific collection (Admin only)',
    options: [
      {
        name: 'collection',
        description: 'Collection address to stop tracking',
        type: ApplicationCommandOptionType.String,
        required: true
require('dotenv').config();
const {
  Client,
  GatewayIntentBits,
  EmbedBuilder,
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ApplicationCommandOptionType,
  REST,
  Routes,
  StringSelectMenuBuilder
} = require('discord.js');
const axios = require('axios');
const cron = require('node-cron');
const fs = require('fs');
const path = require('path');

// Discord client setup
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// Configuration
const config = {
  discordToken: process.env.DISCORD_TOKEN,
  discordAppId: process.env.DISCORD_APP_ID,
  refreshInterval: parseInt(process.env.REFRESH_INTERVAL) || 60000, // Default to 1 minute
};

// API key management
const apiKeyManager = {
  reservoirKeys: [
    'c65ab60c-61a5-5e1c-bb44-d4cc4c0af8a0', // Main key
    '2nd-reservoir-api-key-goes-here',       // Backup key 1
    '3rd-reservoir-api-key-goes-here'        // Backup key 2
  ],
  currentKeyIndex: 0,
  rateLimitDetected: {},
  
  getCurrentKey() {
    return this.reservoirKeys[this.currentKeyIndex];
  },
  
  resetRateLimits() {
    const now = Date.now();
    const oneHourAgo = now - (60 * 60 * 1000);
    
    // Clear rate limit detections older than 1 hour
    for (const key in this.rateLimitDetected) {
      if (this.rateLimitDetected[key] < oneHourAgo) {
        console.log(`🔄 Resetting rate limit status for key ${this.maskApiKey(key)}`);
        delete this.rateLimitDetected[key];
      }
    }
  },
  
  maskApiKey(key) {
    if (!key || key.length < 8) return '****';
    return `${key.substring(0, 4)}...${key.substring(key.length - 4)}`;
  },
  
  rotateKey() {
    const previousKey = this.getCurrentKey();
    const previousIndex = this.currentKeyIndex;
    const now = Date.now();
    
    // Mark current key as rate limited
    this.rateLimitDetected[previousKey] = now;
    
    // Try to find a key that hasn't been rate limited in the last 5 minutes
    const fiveMinutesAgo = now - (5 * 60 * 1000);
    let foundUsableKey = false;
    
    for (let i = 0; i < this.reservoirKeys.length; i++) {
      // Skip to next key index
      this.currentKeyIndex = (this.currentKeyIndex + 1) % this.reservoirKeys.length;
      const nextKey = this.getCurrentKey();
      
      // Check if this key has hit rate limits recently
      if (!this.rateLimitDetected[nextKey] || this.rateLimitDetected[nextKey] < fiveMinutesAgo) {
        foundUsableKey = true;
        console.log(`🔄 Rotating from API key ${this.maskApiKey(previousKey)} to ${this.maskApiKey(nextKey)}`);
        break;
      }
    }
    
    if (!foundUsableKey) {
      // If all keys are rate limited, just use the next one anyway
      console.log(`⚠️ All API keys are rate limited, using key ${this.maskApiKey(this.getCurrentKey())}`);
    }
    
    // If we're back to the same key, log that all keys are rate limited
    if (previousIndex === this.currentKeyIndex) {
      console.log(`⚠️ Tried all API keys, all are rate limited. Using original key again.`);
    }
    
    return this.getCurrentKey();
  },
  
  handleApiError(error) {
    // Check if this is a rate limit error (429 Too Many Requests or 403 Forbidden)
    if (error.response && (error.response.status === 429 || error.response.status === 403)) {
      console.log(`⚠️ Rate limit detected for API key ${this.maskApiKey(this.getCurrentKey())}`);
      return this.rotateKey();
    }
    
    // Not a rate limit error
    return this.getCurrentKey();
  }
};

// File to store server configurations
const SERVER_CONFIG_FILE = 'server-configs.json';

// Server configurations map
let serverConfigs = {};

// Global variables for tracking sales and timestamps
const lastProcessedSales = {
  processedSales: new Map() // saleId => timestamp
};
let lastCheckTime = null; // Timestamp of last check

// Max number of sale IDs to remember (to prevent memory leaks)
const MAX_CACHE_SIZE = 100;

// Slash commands definition
const commands = [
  {
    name: 'setchannel',
    description: 'Set the current channel for NFT sale notifications (Admin only)'
  },
  {
    name: 'track',
    description: 'Start tracking sales for a specific collection',
    options: [
      {
        name: 'collection',
        description: 'Collection address to track',
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ]
  },
  {
    name: 'untrack',
    description: 'Stop tracking sales for a specific collection',
    options: [
      {
        name: 'collection',
        description: 'Collection address to stop tracking',
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ]
  },
  {
    name: 'list',
    description: 'Show all currently tracked collections'
  },
  {
    name: 'help',
    description: 'Show all available commands'
  },
  {
    name: 'test',
    description: 'Send a test notification to verify the bot can post messages'
  },
  {
    name: 'checksales',
    description: 'Force an immediate check for new sales'
  },
  {
    name: 'debug-info',
    description: 'Show bot and channel configuration information for troubleshooting (Admin only)'
  },
  {
    name: 'refresh-images',
    description: 'Refresh all collection images (Admin only)'
  },
  {
    name: 'manage-keys',
    description: 'Manage API keys for the bot (Admin only)',
    options: [
      {
        name: 'action',
        description: 'Action to perform',
        type: ApplicationCommandOptionType.String,
        required: true,
        choices: [
          {
            name: 'list',
            value: 'list'
          },
          {
            name: 'add',
            value: 'add'
          },
          {
            name: 'remove',
            value: 'remove'
          }
        ]
      },
      {
        name: 'key',
        description: 'API key to add or remove',
        type: ApplicationCommandOptionType.String,
        required: false
      }
    ]
  }
];

// Function to register slash commands
async function registerSlashCommands() {
  try {
    console.log('Started refreshing application (/) commands.');
    const rest = new REST({ version: '10' }).setToken(config.discordToken);
    await rest.put(
      Routes.applicationCommands(config.discordAppId),
      { body: commands }
    );
    console.log('Successfully reloaded application (/) commands.');
  } catch (error) {
    console.error('Error registering slash commands:', error);
  }
}

// Load server configurations from file
function loadServerConfigs() {
  try {
    if (fs.existsSync(SERVER_CONFIG_FILE)) {
      const data = fs.readFileSync(SERVER_CONFIG_FILE, 'utf8');
      serverConfigs = JSON.parse(data);
      console.log(`Loaded configurations for ${Object.keys(serverConfigs).length} servers`);
    } else {
      serverConfigs = {};
      console.log('No server configuration file found. Creating new configuration.');
      saveServerConfigs();
    }
  } catch (error) {
    console.error('Error loading server configurations:', error);
    serverConfigs = {};
  }
}

// Save server configurations to file
function saveServerConfigs() {
  try {
    fs.writeFileSync(SERVER_CONFIG_FILE, JSON.stringify(serverConfigs, null, 2), 'utf8');
    console.log('Server configurations saved successfully');
  } catch (error) {
    console.error('Error saving server configurations:', error);
  }
}

// Initialize server configuration if it doesn't exist
function initServerConfig(guildId) {
  if (!serverConfigs[guildId]) {
    serverConfigs[guildId] = {
      notificationChannelId: null,
      trackedCollections: {}
    };
    saveServerConfigs();
  } else if (Array.isArray(serverConfigs[guildId].trackedCollections)) {
    // Convert old format (array) to new format (object)
    const oldCollections = [...serverConfigs[guildId].trackedCollections];
    serverConfigs[guildId].trackedCollections = {};
    oldCollections.forEach(address => {
      serverConfigs[guildId].trackedCollections[address] = {
        address: address,
        source: 'Unknown',
        addedAt: new Date().toISOString()
      };
    });
    saveServerConfigs();
  }
  return serverConfigs[guildId];
}

// Function to fetch token metadata via Reservoir API
async function fetchTokenMetadata(collectionAddress, tokenId) {
  if (!collectionAddress || !tokenId) {
    console.log('Missing collection address or token ID for fetchTokenMetadata');
    return null;
  }
  
  console.log(`Fetching token metadata for ${collectionAddress} token ${tokenId}`);
  
  try {
    // Use v6 API - the newer structure
    const url = `https://api-monad-testnet.reservoir.tools/tokens/v6`;
    console.log(`Making API request to: ${url}`);
    
    const response = await axios.get(url, {
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      params: {
        contract: collectionAddress,
        tokenId: tokenId,
      },
      timeout: 5000
    });
    
    if (response.status === 200 && response.data && response.data.tokens && response.data.tokens.length > 0) {
      const token = response.data.tokens[0];
      console.log(`Found token metadata from Reservoir API: ${token.token?.name || 'Unnamed'}`);
      
      // Log the structure to debug
      console.log('Token data structure:', JSON.stringify(token).substring(0, 300));
      
      // Check different possible locations for the image in the response structure
      const imageUrl = cleanImageUrl(
        token.token?.image || 
        token.tokenImage || 
        token.image || 
        null
      );
      
      console.log(`Token image URL: ${imageUrl || 'Not found'}`);
      
      return {
        name: token.token?.name || `Token #${tokenId}`,
        image: imageUrl,
        description: token.token?.description || null
      };
    } else {
      console.log(`No token metadata found for ${collectionAddress} token ${tokenId}`);
      return null;
    }
  } catch (error) {
    console.error(`Error fetching token metadata for ${collectionAddress} token ${tokenId}:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      
      // Check if this is a rate limit error and rotate keys if needed
      apiKeyManager.handleApiError(error);
      
      if (error.response.data) {
        console.error('Response data:', JSON.stringify(error.response.data).substring(0, 200));
      }
    }
    return null;
  }
}

// Update fetchCollectionInfo to handle automatic key rotation
async function fetchCollectionInfo(collectionAddress) {
  if (!collectionAddress) {
    console.log('No collection address provided for fetchCollectionInfo');
    return null;
  }

  console.log(`Fetching collection info for: ${collectionAddress}`);
  
  // Special handling for Nad Name Service
  if (collectionAddress === '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308') {
    console.log('Using special image for Nad Name Service');
    return {
      name: 'Nad Name Service',
      image: 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg',
      description: 'Nad Name Service is the native naming protocol for Monad.'
    };
  }
  
  // Try Magic Eden API first
  try {
    console.log('Trying Magic Eden API first...');
    const url = `https://api-mainnet.magiceden.dev/v3/rtp/monad-testnet/collections/v7`;
    
    const response = await axios.get(url, {
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      params: {
        contract: collectionAddress,
      },
      timeout: 5000
    });

    if (response.status === 200 && response.data) {
      console.log(`Magic Eden API response:`, JSON.stringify(response.data).substring(0, 300));
      
      // Extract collection name and image from response
      const collection = response.data;
      
      // Check for different possible image field names in the API response
      const imageUrl = cleanImageUrl(
        collection.image || 
        collection.imageUrl || 
        collection.logo ||
        collection.logoURI ||
        null
      );
      
      if (collection.name) {
        console.log(`Found collection name from Magic Eden: ${collection.name}`);
        console.log(`Collection image: ${imageUrl || 'None found'}`);
        
        return {
          name: collection.name,
          image: imageUrl,
          description: collection.description || null
        };
      }
    }
    
    console.log(`No collection data found from Magic Eden for ${collectionAddress}`);
  } catch (error) {
    console.error(`Error fetching collection info from Magic Eden:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      
      // Check if this is a rate limit error and rotate keys if needed
      apiKeyManager.handleApiError(error);
    }
  }
  
  // Fallback to Reservoir API
  try {
    console.log('Falling back to Reservoir API...');
    const url = `https://api-monad-testnet.reservoir.tools/collections/v6`;
    
    const response = await axios.get(url, {
      params: {
        contract: collectionAddress,
      },
      headers: {
        'accept': '*/*',
        'x-api-key': apiKeyManager.getCurrentKey()
      },
      timeout: 5000
    });

    if (response.status === 200 && response.data && response.data.collections && response.data.collections.length > 0) {
      const collection = response.data.collections[0];
      console.log(`Found collection info from Reservoir: ${collection.name}`);
      
      // Log the structure to debug
      console.log('Collection data structure:', JSON.stringify(collection).substring(0, 300));
      
      const imageUrl = cleanImageUrl(collection.image || collection.collectionImage || null);
      
      return {
        name: collection.name || `Monad Collection ${collectionAddress.substring(0, 8)}...`,
        image: imageUrl,
        description: collection.description || null,
        floorPrice: collection.floorAsk?.price?.amount?.native || null,
        tokenCount: collection.tokenCount || null
      };
    } else {
      console.log(`No collection data found from Reservoir for ${collectionAddress}`);
      return {
        name: `Monad Collection ${collectionAddress.substring(0, 8)}...`
      };
    }
  } catch (error) {
    console.error(`Error fetching collection info from Reservoir:`, error.message);
    if (error.response) {
      console.error('Response status:', error.response.status);
      
      // Check if this is a rate limit error and rotate keys if needed
      apiKeyManager.handleApiError(error);
    }
    
    return {
      name: `Monad Collection ${collectionAddress.substring(0, 8)}...`
    };
  }
}

// Function to extract collection address from various formats
function extractCollectionAddress(input) {
  if (!input) return null;
  
  // Clean the input (trim whitespace, remove quotes)
  const cleanedInput = input.trim().replace(/^["']|["']$/g, '');
  
  // If it looks like a contract address (0x format)
  if (/^0x[0-9a-fA-F]{40}$/.test(cleanedInput)) {
    console.log(`Detected contract address format: ${cleanedInput}`);
    return {
      address: cleanedInput,
      source: 'Contract Address'
    };
  }
  
  // Handle address in URL format (from explorer, etc)
  const urlRegex = /0x[0-9a-fA-F]{40}/;
  const urlMatch = cleanedInput.match(urlRegex);
  if (urlMatch) {
    console.log(`Extracted address from URL: ${urlMatch[0]}`);
    return {
      address: urlMatch[0],
      source: 'URL'
    };
  }
  
  // If it doesn't match known patterns but isn't empty, assume it's a direct collection ID
  if (cleanedInput.length > 0) {
    console.log(`Using direct collection ID: ${cleanedInput}`);
    return {
      address: cleanedInput,
      source: 'Direct Collection ID'
    };
  }
  
  // If unable to extract, return null
  console.log(`Could not extract address from: ${input}`);
  return null;
}

// Modify createSaleEmbed function to work well with Reservoir data
function createSaleEmbed(sale) {
  // Get collection name, prioritizing different possible formats
  const collectionName = sale.collection?.name || 
                         sale.collection?.id || 
                         'Unknown Collection';
                         
  // Get token ID and name
  const tokenId = sale.token?.tokenId || 'Unknown';
  const tokenName = sale.token?.name || collectionName;
                  
  // Get price from different possible formats
  let price = sale.price || 'Unknown';
  
  // If price is a string that's not "Unknown", convert to number and format nicely
  if (price !== 'Unknown' && !isNaN(parseFloat(price))) {
    // Convert to number first
    const num = parseFloat(price);
    // Use toLocaleString with proper options to handle decimal places
    price = num.toLocaleString('en-US', {
      minimumFractionDigits: 1,
      maximumFractionDigits: 4
    });
  }
  
  // Find and validate NFT image URL
  const imageUrl = cleanImageUrl(sale.token?.image);
  
  // Format timestamp nicely if it exists and is valid
  let saleTime = null;
  try {
    const timestamp = new Date(sale.createdAt);
    // Check if date is valid
    if (!isNaN(timestamp.getTime())) {
      saleTime = timestamp.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  } catch (e) {
    console.log('Invalid timestamp format, skipping time display');
  }
  
  // Get transaction hash
  const txHash = sale.transaction || sale.txHash;
  const txUrl = `https://testnet.monadexplorer.com/tx/${txHash}`;
  
  // Use blue sidebar color (#007bff) like in the first image
  let embedColor = '#007bff';
  
  // Create the title that links to transaction
  const title = 'New Sale!';
  
  // Create the custom format showing NFT Name #tokenId has sold for X MON
  let saleDescription = `**${tokenName} #${tokenId} has sold for ${price} MON**`;
  
  // Only add time if it's valid
  // Time display has been removed per user request
  /*
  if (saleTime) {
    saleDescription += `\n\n**Time:** ${saleTime}`;
  }
  */
  
  // Create the embed with the styling matching the screenshot
  let embed = new EmbedBuilder()
    .setColor(embedColor)
    .setTitle(title)
    .setURL(txUrl) // Make the title clickable with the transaction URL
    .setDescription(saleDescription)
    .setTimestamp();
  
  // Add token image if available and valid
  if (imageUrl) {
    embed.setImage(imageUrl);
    console.log(`Set image URL in embed: ${imageUrl}`);
  } else {
    console.log(`No valid image URL available for this sale`);
  }
  
  // Add footer with source and transaction hash
  embed.setFooter({ 
    text: `Source: Reservoir | ${shortenAddress(txHash)}`,
    iconURL: 'https://reservoir.tools/reservoir.svg'
  });
  
  // Add transaction and addresses to fields
  const fields = [];
  
  // Get seller address
  const seller = sale.seller || sale.fromAddress;
  if (seller) {
    fields.push({ 
      name: 'Seller', 
      value: `[${shortenAddress(seller)}](https://testnet.monadexplorer.com/address/${seller})`, 
      inline: true 
    });
  }
  
  // Get buyer address
  const buyer = sale.buyer || sale.toAddress;
  if (buyer) {
    fields.push({ 
      name: 'Buyer', 
      value: `[${shortenAddress(buyer)}](https://testnet.monadexplorer.com/address/${buyer})`, 
      inline: true 
    });
  }
  
  // Add fields if we have any
  if (fields.length > 0) {
    embed.addFields(fields);
  }
  
  return embed;
}

// Helper function to shorten addresses
function shortenAddress(address) {
  if (!address) return 'Unknown';
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
}

// Clean up server configs - simplified 
function cleanServerConfigurations() {
  console.log('Checking and cleaning server configurations...');
  for (const [guildId, serverConfig] of Object.entries(serverConfigs)) {
    if (!serverConfig.trackedCollections) continue;
    
    // Ensure all collections have proper address format
    const collections = serverConfig.trackedCollections;
    const newCollections = {};
    
    for (const [address, metadata] of Object.entries(collections)) {
      // Only keep valid addresses
      if (address.startsWith('0x')) {
        newCollections[address] = {
          ...metadata,
          address: address
        };
      }
    }
    
    serverConfig.trackedCollections = newCollections;
  }
  saveServerConfigs();
}

// Debug function to show cache status
function debugCacheStatus() {
  console.log(`Sales cache size: ${lastProcessedSales.processedSales.size} entries`);
}

// Function to fetch NFT sales from Reservoir API
async function fetchReservoirSales(collections) {
  if (!collections || collections.length === 0) {
    console.log("No collections to monitor for sales");
    return [];
  }
  
  console.log("🔍 Monitoring collections with Reservoir API:", collections);
  
  // Store all detected sales here
  const detectedSales = [];
  
  try {
    // Reservoir API configuration
    const RESERVOIR_API_KEY = apiKeyManager.getCurrentKey();
    const RESERVOIR_API_URL = "https://api-monad-testnet.reservoir.tools/collections/activity/v6";
    
    // For each collection, fetch recent activities
    for (const collectionAddress of collections) {
      console.log(`🔍 Checking activities for collection: ${collectionAddress}`);
      
      // Make request to Reservoir API
      console.log(`Making API request to: ${RESERVOIR_API_URL}?collection=${collectionAddress}`);
      const response = await axios.get(RESERVOIR_API_URL, {
        headers: {
          'accept': '*/*',
          'x-api-key': RESERVOIR_API_KEY
        },
        params: {
          collection: collectionAddress,
          limit: 20,
          types: 'sale'
        },
        timeout: 10000
      });
      
      console.log(`✅ API request successful. Status: ${response.status}`);
      
      if (!response.data || !response.data.activities) {
        console.log(`❌ No data returned from Reservoir for ${collectionAddress}`);
        console.log("Response structure:", JSON.stringify(response.data).substring(0, 500));
        continue;
      }

      // Process the activities
      const activities = response.data.activities || [];
      console.log(`📊 Found ${activities.length} activities for ${collectionAddress}`);
      
      if (activities.length === 0) {
        console.log("⚠️ No activities found for this collection");
        continue;
      }
      
      // Log first activity if available for debugging
      if (activities.length > 0) {
        console.log(`📝 Sample activity: ${JSON.stringify(activities[0], null, 2)}`);
       }
       
      // Process each sale activity
      for (const activity of activities) {
        if (activity.type === 'sale') {
          console.log(`🔔 Detected sale via Reservoir for collection ${collectionAddress}`);
          
          // Extract token ID from activity
          const tokenId = activity.token?.tokenId || null;
          
          // Clean up the image URL if present
          const tokenImage = cleanImageUrl(activity.token?.tokenImage);
          
          // Initialize sale object with data from activity
          const sale = {
            id: activity.txHash || `reservoir_${Date.now()}`,
            collection: {
              id: collectionAddress,
              name: activity.collection?.collectionName || `Collection ${collectionAddress.substring(0, 6)}...`
            },
            price: activity.price?.amount?.native || 'Unknown',
            type: 'Sale',
            createdAt: activity.timestamp || new Date().toISOString(),
            buyer: activity.toAddress,
            seller: activity.fromAddress,
            token: {
              image: tokenImage,
              tokenId: tokenId || `unknown-${Date.now()}`,
              name: activity.token?.tokenName || null
            },
            transaction: activity.txHash
          };
          
          // Try to fetch additional token metadata directly from Reservoir if image is missing
          if ((tokenId && (!sale.token.image || sale.token.image === null)) || !sale.token.name) {
            console.log(`🖼️ Trying to fetch additional metadata for token ${tokenId}`);
            try {
              const tokenMetadata = await fetchTokenMetadata(collectionAddress, tokenId);
              if (tokenMetadata) {
                if (tokenMetadata.image && !sale.token.image) {
                  console.log(`🖼️ Found image for token ${tokenId}`);
                  sale.token.image = tokenMetadata.image;
                }
                
                if (tokenMetadata.name && !sale.token.name) {
                  sale.token.name = tokenMetadata.name;
                }
              }
            } catch (metadataError) {
              console.error(`❌ Error fetching token metadata: ${metadataError.message}`);
            }
          }
          
          console.log("🎯 Sale object created:", JSON.stringify(sale, null, 2));
          detectedSales.push(sale);
        }
      }
      
      console.log(`📊 Summary for ${collectionAddress}: ${activities.filter(a => a.type === 'sale').length} sales detected out of ${activities.length} activities`);
     }
  
  console.log(`📋 Total sales detected: ${detectedSales.length}`);
  return detectedSales;
  } catch (error) {
    console.error("❌ Error fetching Reservoir sales:", error.message);
    if (error.response) {
      console.error("Response status:", error.response.status);
      console.error("Response data:", JSON.stringify(error.response.data).substring(0, 500));
      
      // Try with a different API key if rate limited
      apiKeyManager.handleApiError(error);
    } else if (error.request) {
      console.error("No response received:", error.request);
    } else {
      console.error("Error details:", error);
    }
    return [];
  }
}

// Updated processSales function to optionally skip notifications (for initialization)
async function processSales(sendNotifications = true) {
  try {
    console.log(`=================== PROCESSING SALES (Notifications: ${sendNotifications ? "ON" : "OFF"}) ===================`);
    debugCacheStatus();
    
    // Track if we found any sales
    let salesFound = false;
    let notificationsSent = 0;
    let newSalesFound = 0;
    
    // Clean up old cache entries (older than 1 hour)
    const now = Date.now();
    const ONE_HOUR = 60 * 60 * 1000;
    let cacheEntriesRemoved = 0;
    for (const [saleId, timestamp] of lastProcessedSales.processedSales.entries()) {
      if (now - timestamp > ONE_HOUR) {
        lastProcessedSales.processedSales.delete(saleId);
        cacheEntriesRemoved++;
      }
    }
    console.log(`Cleaned up ${cacheEntriesRemoved} old entries from sales cache`);
    
    // Process for each server with configuration
    const serverCount = Object.keys(serverConfigs).length;
    console.log(`Processing ${serverCount} Discord servers`);
    
    for (const [guildId, serverConfig] of Object.entries(serverConfigs)) {
      // Skip if no collections are being tracked or no notification channel is set
      if (!serverConfig.trackedCollections || 
          Object.keys(serverConfig.trackedCollections).length === 0 || 
          !serverConfig.notificationChannelId) {
        console.log(`⏩ Skipping guild ${guildId}: no collections tracked or no notification channel set`);
        continue;
      }

      // Get the guild and channel
      const guild = client.guilds.cache.get(guildId);
      if (!guild) {
        console.log(`Guild not found: ${guildId}`);
        continue;
      }

      const channel = guild.channels.cache.get(serverConfig.notificationChannelId);
      if (!channel) {
        console.log(`Notification channel not found for guild: ${guild.name}`);
        continue;
      }

      console.log(`Processing sales for guild: ${guild.name} (${guildId})`);
      console.log(`Total tracked collections: ${Object.keys(serverConfig.trackedCollections).length}`);
      
      // Check channel permissions
      const botPermissions = channel.permissionsFor(client.user);
      if (!botPermissions.has('SendMessages') || !botPermissions.has('EmbedLinks')) {
        console.log(`Bot lacks permissions in channel #${channel.name}: Cannot send messages or embed links`);
        continue;
      } else {
        console.log(`Bot has required permissions in channel #${channel.name}`);
      }

      try {
        // Extract collection addresses from tracked collections
        const collectionAddresses = Object.values(serverConfig.trackedCollections)
          .map(collection => typeof collection === 'string' ? collection : collection.address);

        // Process Reservoir sales
        console.log("Fetching sales via Reservoir API...");
        const reservoirSales = await fetchReservoirSales(collectionAddresses);
        console.log(`Detected ${reservoirSales.length} sales via Reservoir API`);
        
        // Sort sales by timestamp if available to process oldest first
        reservoirSales.sort((a, b) => {
          const timeA = new Date(a.createdAt).getTime() || 0;
          const timeB = new Date(b.createdAt).getTime() || 0;
          return timeA - timeB;
        });
        
        if (reservoirSales.length > 0) {
          salesFound = true;
          
          // Log all sales found
          console.log("Sales detected:");
          reservoirSales.forEach((sale, index) => {
            console.log(`Sale ${index + 1}/${reservoirSales.length}:`, 
              `collection=${sale.collection.id}`, 
              `saleId=${sale.id}`,
              `time=${sale.createdAt}`,
              `processed=${lastProcessedSales.processedSales.has(sale.id)}`);
          });
        } else {
          console.log("No sales detected via Reservoir API");
        }
        
        // Examine each sale
        for (const sale of reservoirSales) {
          // Get unique ID for sales
          const saleId = sale.id || `reservoir_${Date.now()}`;
          
          // Get timestamp from sale or use current time
          const timestamp = new Date(sale.createdAt).getTime() || Date.now();
          const saleTime = new Date(timestamp).toISOString();
          
          console.log(`Processing sale with ID: ${saleId} from ${saleTime}`);
          console.log(`Already processed? ${lastProcessedSales.processedSales.has(saleId)}`);
          
          // If we haven't processed this sale in the cache period
          if (saleId && !lastProcessedSales.processedSales.has(saleId)) {
            // Add to processed map with current timestamp
            lastProcessedSales.processedSales.set(saleId, Date.now());
            console.log(`Added sale ID to processed cache: ${saleId}`);
            console.log(`Cache size now: ${lastProcessedSales.processedSales.size}`);
            newSalesFound++;
            
            // Trim cache if needed
            if (lastProcessedSales.processedSales.size > MAX_CACHE_SIZE) {
              // Get oldest entry (first item)
              const oldestKey = Array.from(lastProcessedSales.processedSales.keys())[0];
              lastProcessedSales.processedSales.delete(oldestKey);
              console.log(`Trimmed oldest sale from cache: ${oldestKey}`);
              console.log(`Cache size after trim: ${lastProcessedSales.processedSales.size}`);
            }
            
            // Send notification to Discord if enabled
            if (sendNotifications) {
              console.log("📝 Creating embed for sale notification");
              const embed = createSaleEmbed(sale);
              
              const collectionName = sale.collection?.name || 
                                   sale.collection?.id || 
                                   'Unknown Collection';
              
              console.log(`SENDING NOTIFICATION for ${collectionName} sale (${saleId})`);
              try {
                await channel.send({ embeds: [embed] });
                console.log(`NOTIFICATION SENT SUCCESSFULLY for ${collectionName}!`);
                notificationsSent++;
              } catch (sendError) {
                console.error(`❌ ERROR SENDING NOTIFICATION: ${sendError.message}`);
                console.error("Is the bot allowed to post in this channel?");
                console.error("Full error:", sendError);
              }
            } else {
              console.log(`⏩ Skipping notification since notifications are disabled (${saleId})`);
            }
          } else {
            console.log(`⏩ Skipping sale ID ${saleId} - already processed or missing ID`);
          }
        }
      } catch (error) {
        console.error(`❌ Error processing sales for guild ${guild.name}:`, error.message);
        console.error("Full error:", error);
      }
    }
    
    if (!salesFound) {
      console.log("No sales found across all guilds");
    } else if (newSalesFound === 0) {
      console.log("No new sales found - all sales were already in cache");
    } else {
      console.log(`SALES PROCESSING COMPLETE - Found ${newSalesFound} new sales, sent ${notificationsSent} notifications`);
    }
  } catch (error) {
    console.error("❌ Error in processSales:", error.message);
    console.error("Full error:", error);
  }
}

// Check if user has admin permissions
function isAdmin(member) {
  return member.permissions.has(PermissionFlagsBits.Administrator);
}

// Function to update existing tracked collections with fresh info
async function updateCollectionInfo(guildId) {
  if (!serverConfigs[guildId] || !serverConfigs[guildId].trackedCollections) {
    return;
  }

  const collections = serverConfigs[guildId].trackedCollections;
  for (const [address, metadata] of Object.entries(collections)) {
    if (metadata.name === 'Unknown Collection' || !metadata.name) {
      try {
        console.log(`Updating info for collection ${address}`);
        // Just use our basic info format
        collections[address] = {
          ...metadata,
          address: address,
          name: `Monad Collection ${address.substring(0, 6)}...`,
          lastUpdated: new Date().toISOString()
        };
      } catch (error) {
        console.error(`Error updating collection info for ${address}:`, error.message);
      }
    }
  }
  saveServerConfigs();
}

// Function to validate an Ethereum collection address
function validateCollectionAddress(address) {
  if (!address) return false;
  
  // Basic format check (0x followed by 40 hex characters)
  const addressRegex = /^0x[0-9a-fA-F]{40}$/;
  const isValidFormat = addressRegex.test(address);
  
  if (!isValidFormat) {
    console.log(`Invalid address format: ${address}`);
    return false;
  }
  
  console.log(`Address format is valid: ${address}`);
  return true;
}

// Handle slash commands
client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand() && !interaction.isButton()) return;
  
  try {
    // Handle button interactions
    if (interaction.isButton()) {
      // Handle pagination buttons
      if (interaction.customId.startsWith('page_')) {
        const [_, currentPage, action] = interaction.customId.split('_');
        const guildId = interaction.guildId;
        
        if (!serverConfigs[guildId]) {
          await interaction.reply({ content: 'Server configuration not found.', ephemeral: true });
          return;
        }
        
        const trackedCollections = serverConfigs[guildId].trackedCollections;
        const newPage = action === 'next' ? parseInt(currentPage) + 1 : parseInt(currentPage) - 1;
        
        const { embed: embeds, currentPage: validatedPage, totalPages } = createCollectionListEmbed(
          trackedCollections,
          interaction.guild.name,
          newPage,
          5
        );
        
        const components = createCollectionListComponents(validatedPage, totalPages, trackedCollections);
        await interaction.update({ embeds: embeds, components });
        return;
      }
      
      // Handle individual untrack buttons
      if (interaction.customId.startsWith('untrack_')) {
        // Only admins can untrack collections
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to untrack collections.', ephemeral: true });
          return;
        }
        
        const [_, address, currentPage] = interaction.customId.split('_');
        const guildId = interaction.guildId;
        
        if (!serverConfigs[guildId] || !serverConfigs[guildId].trackedCollections[address]) {
          await interaction.reply({ content: 'That collection is no longer being tracked.', ephemeral: true });
          return;
        }
        
        const collectionName = serverConfigs[guildId].trackedCollections[address].name || 
                               `Collection ${address.substring(0, 8)}...`;
        
        // Delete the collection from tracking
        delete serverConfigs[guildId].trackedCollections[address];
        saveServerConfigs();
        
        // Refresh the list with the updated collections
        const trackedCollections = serverConfigs[guildId].trackedCollections;
        
        if (Object.keys(trackedCollections).length === 0) {
          // No more collections
          await interaction.update({ 
            content: `Successfully untracked **${collectionName}**. No more collections are being tracked.`,
            embeds: [], 
            components: [] 
          });
          return;
        }
        
        // Get updated embed and components
        const pageNum = parseInt(currentPage) || 1;
        const { embed: embeds, currentPage: validatedPage, totalPages } = createCollectionListEmbed(
          trackedCollections,
          interaction.guild.name,
          pageNum,
          5
        );
        
        const components = createCollectionListComponents(validatedPage, totalPages, trackedCollections);
        
        await interaction.update({
          content: `Successfully untracked **${collectionName}**. Updated tracking list:`,
          embeds: embeds,
          components
        });
        return;
      }
      
      if (interaction.customId === 'refresh_list') {
        // Only admins can refresh the list
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to refresh the list.', ephemeral: true });
          return;
        }
        
        // Rerun the list command logic
        const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
        if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
          await interaction.update({ content: 'No collections are currently being tracked.', embeds: [], components: [] });
          return;
        }
        
        try {
          // Use the paginated list display with individual untrack buttons
          const { embed: embeds, currentPage, totalPages } = createCollectionListEmbed(
            trackedCollections,
            interaction.guild.name,
            1,
            5
          );
          
          // Get components with untrack buttons for each collection
          const components = createCollectionListComponents(currentPage, totalPages, trackedCollections);
          
          await interaction.update({
            embeds: embeds,
            components: components
          });
        } catch (error) {
          console.error('Error refreshing tracked collections:', error);
          await interaction.update({ content: 'An error occurred while refreshing the list of tracked collections.', embeds: [], components: [] });
        }
        return;
      }
    }

    // Handle slash commands
    if (!interaction.isCommand()) return;
    if (!interaction.guildId) {
      await interaction.reply({ content: 'This command can only be used in a server.', ephemeral: true });
      return;
    }

    const guildId = interaction.guildId;
    const serverConfig = initServerConfig(guildId);

    const { commandName, options } = interaction;

    switch (commandName) {
      case 'setchannel':
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        serverConfig.notificationChannelId = interaction.channelId;
        saveServerConfigs();
        await interaction.reply({ content: `Set this channel as the notification channel for NFT sales!`, ephemeral: true });
        break;
        
      case 'track': {
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const collectionInput = interaction.options.getString('collection');
          if (!collectionInput) {
            await interaction.editReply('Please provide a collection address to track.');
            return;
          }
          
          const collectionData = extractCollectionAddress(collectionInput);
          if (!collectionData || !collectionData.address) {
            await interaction.editReply('Invalid collection address format. Please provide a valid Ethereum address.');
            return;
          }
          
          const address = collectionData.address;
          
          if (!validateCollectionAddress(address)) {
            await interaction.editReply('Invalid collection address format. Please provide a valid Ethereum address.');
            return;
          }
          
          // Check if server config exists
          if (!serverConfigs[interaction.guildId]) {
            initServerConfig(interaction.guildId);
          }
          
          // Check if notifications channel is set
          if (!serverConfigs[interaction.guildId].notificationChannelId) {
            await interaction.editReply('Please set a notification channel first using /setchannel command.');
            return;
          }
          
          // Check if collection is already tracked
          if (serverConfigs[interaction.guildId].trackedCollections[address]) {
            await interaction.editReply(`Collection ${address} is already being tracked.`);
            return;
          }
          
          // Send loading message while fetching collection info
          await interaction.editReply('🔍 Fetching collection information, please wait...');
          
          // Try to get collection info first
          let collectionInfo = null;
          try {
            collectionInfo = await fetchCollectionInfo(address);
          } catch (infoError) {
            console.error('Error fetching collection info:', infoError);
          }
          
          // Use fetched name or default
          const collectionName = collectionInfo && collectionInfo.name ? 
            collectionInfo.name : `Monad Collection ${address.substring(0, 8)}...`;
          
          // Add collection to tracking list with info
          serverConfigs[interaction.guildId].trackedCollections[address] = {
            address: address,
            name: collectionName,
            addedAt: new Date().toISOString(),
            addedBy: interaction.user.id,
            source: collectionData.source || 'Contract Address'
          };
          
          // Add image if available
          if (collectionInfo && collectionInfo.image) {
            serverConfigs[interaction.guildId].trackedCollections[address].image = collectionInfo.image;
          }
          
          // Save config
          saveServerConfigs();
          
          // Immediately check this collection for sales
          console.log(`🔍 Immediately checking the newly added collection ${address} for sales...`);
          try {
            const salesCount = await checkSingleCollection(address);
            console.log(`✅ Initial check complete for ${address}: Found ${salesCount} existing sales to cache`);
          } catch (error) {
            console.error(`❌ Error in initial collection check:`, error.message);
          }
          
          // Create tracking confirmation embed with green sidebar that exactly matches the screenshot
          const trackingEmbed = new EmbedBuilder()
            .setColor('#4caf50') // Green color for the sidebar
            .setTitle(`Now Tracking: ${collectionName}`)
            .setDescription(`Successfully added to tracking list.`)
            .addFields(
              { name: 'Address', value: `${address}` },
              { name: 'Source', value: collectionData.source || 'Contract Address', inline: true },
              { name: 'Added By', value: `@${interaction.user.username}`, inline: true }
            )
            .addFields(
              { name: 'How to Untrack', value: `Use \`/untrack collection:${address}\`\nor click untrack in the \`/list\`.` }
            )
            .setTimestamp();
          
          // Add collection thumbnail if available
          if (collectionInfo && collectionInfo.image) {
            trackingEmbed.setThumbnail(collectionInfo.image);
          }
          
          await interaction.editReply({ content: null, embeds: [trackingEmbed] });
        } catch (error) {
          console.error('Error tracking collection:', error);
          await interaction.editReply('An error occurred while trying to track the collection.');
        }
        break;
      }
        
      case 'untrack': {
        const untrackInput = options.getString('collection');
        if (!untrackInput) {
          await interaction.deferReply({ ephemeral: true });
          try {
            const { embed: embeds } = createCollectionListEmbed(
              serverConfig.trackedCollections,
              interaction.guild.name,
              1,
              5
            );
            await interaction.editReply({
              content: 'No collection given. Here are your tracked collections:',
              embeds: embeds,
              ephemeral: true
            });
          } catch (error) {
            console.error('Error in untrack command (no address):', error);
            await interaction.editReply({
              content: 'Error retrieving your tracked collections. Try again later.',
              ephemeral: true
            });
          }
          return;
        }
        // If user gave a number
        if (/^\d+$/.test(untrackInput.trim())) {
          const collectionNumber = parseInt(untrackInput.trim());
          const collectionEntries = Object.entries(serverConfig.trackedCollections);
          if (collectionNumber <= 0 || collectionNumber > collectionEntries.length) {
            await interaction.reply({
              content: `Invalid number. Must be between 1 and ${collectionEntries.length}.`,
              ephemeral: true
            });
            return;
          }
          const [addressToRemove, data] = collectionEntries[collectionNumber - 1];
          const cName = data.name || addressToRemove;
          delete serverConfig.trackedCollections[addressToRemove];
          saveServerConfigs();
          await interaction.reply({
            content: `No longer tracking collection #${collectionNumber}: ${cName}`,
            ephemeral: true
          });
          return;
        }
        
        // If user gave an address or partial name
        if (serverConfig.trackedCollections[untrackInput]) {
          const cName = serverConfig.trackedCollections[untrackInput].name || untrackInput;
          delete serverConfig.trackedCollections[untrackInput];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking: ${cName}`, ephemeral: true });
          return;
        }
        const collectionEntries = Object.entries(serverConfig.trackedCollections);
        const matchByName = collectionEntries.find(([_, data]) => {
          return data.name && data.name.toLowerCase().includes(untrackInput.toLowerCase());
        });
        if (matchByName) {
          const [addr, data] = matchByName;
          delete serverConfig.trackedCollections[addr];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking: ${data.name}`, ephemeral: true });
          return;
        }
        
        const untrackData = extractCollectionAddress(untrackInput);
        const untrackAddress = untrackData ? untrackData.address : untrackInput;
        if (serverConfig.trackedCollections[untrackAddress]) {
          const cName = serverConfig.trackedCollections[untrackAddress].name || untrackAddress;
          delete serverConfig.trackedCollections[untrackAddress];
          saveServerConfigs();
          await interaction.reply({ content: `No longer tracking collection: ${cName}`, ephemeral: true });
        } else {
          await interaction.deferReply({ ephemeral: true });
          try {
            const { embed: embeds } = createCollectionListEmbed(
              serverConfig.trackedCollections,
              interaction.guild.name,
              1,
              5
            );
            await interaction.editReply({
              content: `Could not find a collection matching "${untrackInput}". Here are your tracked collections:`,
              embeds: embeds,
              ephemeral: true
            });
          } catch (error) {
            console.error('Error in untrack command (not found):', error);
            await interaction.editReply({
              content: `Could not find a matching collection. Use /list to see them.`,
              ephemeral: true
            });
          }
        }
        break;
      }
        
      case 'list': {
        if (!serverConfigs[interaction.guildId]) {
          await interaction.reply({ content: 'No server configuration found. Please use /track to start tracking collections.', ephemeral: true });
          return;
        }
        
        const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
        if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
          await interaction.reply({ content: 'No collections are currently being tracked.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          // Use the paginated list display with individual untrack buttons
          const { embed: embeds, currentPage, totalPages } = createCollectionListEmbed(
            trackedCollections,
            interaction.guild.name,
            1,
            5
          );
          
          // Get components with untrack buttons for each collection
          const components = createCollectionListComponents(currentPage, totalPages, trackedCollections);
          
          await interaction.editReply({
            embeds: embeds,
            components: components
          });
        } catch (error) {
          console.error('Error displaying tracked collections:', error);
          await interaction.editReply('An error occurred while retrieving the list of tracked collections.');
        }
        break;
      }
      
      case 'test': {
        await interaction.deferReply({ ephemeral: true });
        try {
          if (!serverConfig.notificationChannelId) {
            await interaction.editReply({ 
              content: 'No notification channel set for this server. Use /setchannel to set one.', 
              ephemeral: true 
            });
            return;
          }
          
          const channel = interaction.guild.channels.cache.get(serverConfig.notificationChannelId);
          if (!channel) {
            await interaction.editReply({ 
              content: 'The notification channel could not be found. It may have been deleted.', 
              ephemeral: true 
            });
            return;
          }
          
          const perms = channel.permissionsFor(client.user);
          if (!perms.has('SendMessages') || !perms.has('EmbedLinks')) {
            await interaction.editReply({ 
              content: `The bot doesn't have permission to send messages or embeds in <#${channel.id}>. Please update channel permissions.`, 
              ephemeral: true 
            });
            return;
          }
          
          // Send test notification
          const success = await testNotification(guildId);
          
          if (success) {
            await interaction.editReply({ 
              content: `✅ Test notification sent successfully to <#${channel.id}>! If you can see it, the bot is working correctly.`, 
              ephemeral: true 
            });
          } else {
            await interaction.editReply({ 
              content: `❌ Failed to send test notification to <#${channel.id}>. Check the console logs for details.`, 
              ephemeral: true 
            });
          }
        } catch (error) {
          console.error('Error in test command:', error);
          await interaction.editReply({
            content: 'Error sending test notification. Check the console logs for details.',
            ephemeral: true
          });
        }
        break;
      }

      case 'checksales': {
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        try {
          // Don't clear the sales cache - instead just run the same check as the automated process
          // This ensures we only notify for new sales since the last check
          await interaction.editReply({ content: '🔍 Checking for new sales... Please wait...', ephemeral: true });
          
          // Force sales check for all configured servers
          const serverIds = Object.keys(serverConfigs);
          let successCount = 0;
          
          for (const serverId of serverIds) {
            const serverConfig = serverConfigs[serverId];
            if (!serverConfig || !serverConfig.trackedCollections || Object.keys(serverConfig.trackedCollections).length === 0) {
              continue;
            }
            
            try {
              await checkAndNotifySales(serverId);
              successCount++;
            } catch (checkError) {
              console.error(`Error checking sales for server ${serverId}:`, checkError);
            }
          }
          
          await interaction.editReply({ 
            content: `✅ Sales check complete for ${successCount} servers! Check your notification channel for any new sale notifications.`, 
            ephemeral: true 
          });
        } catch (error) {
          console.error('Error checking sales:', error);
          await interaction.editReply({ content: 'An error occurred while checking for sales.', ephemeral: true });
        }
        break;
      }

      case 'help':
        const helpEmbed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('NFT Sales Bot Commands')
          .setDescription('Here are the commands you can use:')
          .addFields(
            { name: '/setchannel', value: 'Set the current channel for sales notifications (Admin only)' },
            { name: '/track <collection>', value: 'Track sales for a specific collection (Monad contract address)' },
            { name: '/untrack <collection>', value: 'Stop tracking a collection. You can supply the address or the list index' },
            { name: '/list', value: 'Show all currently tracked collections (with pagination)' },
            { name: '/test', value: 'Send a test notification to verify the bot can post messages' },
            { name: '/checksales', value: 'Force an immediate check for new sales (Admin only)' },
            { name: '/refresh-images', value: 'Refresh collection images from APIs (Admin only)' },
            { name: '/manage-keys', value: 'Manage API keys for automatic rotation when rate limits are hit (Admin only)' },
            { name: '/help', value: 'Show this help message' }
          );
        await interaction.reply({ embeds: [helpEmbed], ephemeral: true });
        break;

      case 'debug-info': {
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const guildId = interaction.guildId;
          const serverConfig = serverConfigs[guildId] || { notificationChannelId: null, trackedCollections: {} };
          
          // Get notifications channel info
          const notificationChannelId = serverConfig.notificationChannelId || serverConfig.notificationChannel;
          let channelInfo = 'Not set';
          
          if (notificationChannelId) {
            const channel = interaction.guild.channels.cache.get(notificationChannelId);
            if (channel) {
              channelInfo = `<#${channel.id}> (${channel.name})`;
              
              // Check permissions
              const perms = channel.permissionsFor(client.user);
              if (!perms.has('SendMessages') || !perms.has('EmbedLinks')) {
                channelInfo += ' ⚠️ BOT MISSING PERMISSIONS';
              } else {
                channelInfo += ' ✅ Permissions OK';
              }
            } else {
              channelInfo = `ID: ${notificationChannelId} (CHANNEL NOT FOUND)`;
            }
          }
          
          // Get tracking status
          const collectionCount = Object.keys(serverConfig.trackedCollections || {}).length;
          const collectionList = Object.entries(serverConfig.trackedCollections || {})
            .map(([address, data]) => {
              const name = data.name || address;
              return `- ${name} (${address.substring(0, 8)}...)`;
            })
            .join('\n');
          
          // Get cache info
          const cacheSize = lastProcessedSales.processedSales.size;
          const lastCheckInfo = lastCheckTime ? lastCheckTime.toLocaleString() : 'Never';
          
          // Create a debug embed
          const debugEmbed = new EmbedBuilder()
            .setColor('#ff9900')
            .setTitle('Bot Debug Information')
            .setDescription(`Current configuration and status for this server`)
            .addFields(
              { name: 'Server ID', value: guildId, inline: true },
              { name: 'Configuration File', value: SERVER_CONFIG_FILE, inline: true },
              { name: 'Last Check Time', value: lastCheckInfo, inline: true },
              { name: 'Notification Channel', value: channelInfo, inline: false },
              { name: 'Collections Tracked', value: collectionCount > 0 ? 
                `${collectionCount} collections\n${collectionList}` : 'None', inline: false },
              { name: 'Sales Cache Size', value: `${cacheSize} entries`, inline: true },
              { name: 'Check Interval', value: `${config.refreshInterval / 1000} seconds`, inline: true }
            )
            .setFooter({ text: `Bot Version: 1.4.0` })
            .setTimestamp();
            
          await interaction.editReply({ embeds: [debugEmbed], ephemeral: true });
          
        } catch (error) {
          console.error('Error in debug-info command:', error);
          await interaction.editReply({
            content: `Error generating debug info: ${error.message}`,
            ephemeral: true
          });
        }
        break;
      }

      case 'refresh-images': {
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const trackedCollections = serverConfigs[interaction.guildId].trackedCollections;
          if (!trackedCollections || Object.keys(trackedCollections).length === 0) {
            await interaction.editReply('No collections are currently being tracked.');
            return;
          }
          
          let updatedCount = 0;
          let failedCount = 0;
          const collectionAddresses = Object.keys(trackedCollections);
          
          await interaction.editReply(`🔄 Refreshing images for ${collectionAddresses.length} collections...`);
          
          for (const address of collectionAddresses) {
            try {
              // Try to get fresh collection info
              const collectionInfo = await fetchCollectionInfo(address);
              
              if (collectionInfo && collectionInfo.image) {
                // Update the collection image if one was found
                trackedCollections[address].image = collectionInfo.image;
                updatedCount++;
              } else {
                // If no image found from APIs, try a special case for known collections
                if (address === '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308') {
                  trackedCollections[address].image = 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg'; // Twitter image for NNS
                  updatedCount++;
                } else {
                  failedCount++;
                }
              }
            } catch (error) {
              console.error(`Error refreshing image for collection ${address}:`, error);
              failedCount++;
            }
          }
          
          // Save updated config
          saveServerConfigs();
          
          // Create update confirmation embed
          const refreshEmbed = new EmbedBuilder()
            .setColor('#4caf50')
            .setTitle('Collection Images Refreshed')
            .setDescription(`Successfully refreshed images for ${updatedCount} collections.${failedCount > 0 ? `\n⚠️ Failed to refresh ${failedCount} collections.` : ''}`)
            .setTimestamp();
          
          await interaction.editReply({ content: null, embeds: [refreshEmbed] });
        } catch (error) {
          console.error('Error refreshing collection images:', error);
          await interaction.editReply('An error occurred while trying to refresh collection images.');
        }
        break;
      }
      
      case 'manage-keys': {
        if (!isAdmin(interaction.member)) {
          await interaction.reply({ content: 'You need administrator permissions to use this command.', ephemeral: true });
          return;
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        try {
          const action = interaction.options.getString('action');
          const key = interaction.options.getString('key');
          
          if (action === 'list') {
            // Create an embed to show all current API keys (masked for security)
            const keysEmbed = new EmbedBuilder()
              .setColor('#2196f3')
              .setTitle('API Keys')
              .setDescription('Current API keys used by the bot:')
              .setTimestamp();
              
            // Add fields for each key, showing part of the key masked
            apiKeyManager.reservoirKeys.forEach((key, index) => {
              const maskedKey = apiKeyManager.maskApiKey(key);
              keysEmbed.addFields({
                name: `Key ${index + 1}${index === apiKeyManager.currentKeyIndex ? ' (current)' : ''}`,
                value: maskedKey
              });
            });
            
            await interaction.editReply({ embeds: [keysEmbed] });
          } 
          else if (action === 'add') {
            if (!key) {
              await interaction.editReply('Please provide an API key to add.');
              return;
            }
            
            // Check if key already exists
            if (apiKeyManager.reservoirKeys.includes(key)) {
              await interaction.editReply('This API key is already in use.');
              return;
            }
            
            // Add the new key
            apiKeyManager.reservoirKeys.push(key);
            
            await interaction.editReply(`✅ Added new API key: ${apiKeyManager.maskApiKey(key)}`);
          }
          else if (action === 'remove') {
            if (!key) {
              await interaction.editReply('Please provide an API key to remove.');
              return;
            }
            
            // Check if key exists
            const keyIndex = apiKeyManager.reservoirKeys.indexOf(key);
            if (keyIndex === -1) {
              await interaction.editReply('This API key was not found.');
              return;
            }
            
            // Don't remove the last key
            if (apiKeyManager.reservoirKeys.length <= 1) {
              await interaction.editReply('Cannot remove the last API key. Add a new one first.');
              return;
            }
            
            // Remove the key
            apiKeyManager.reservoirKeys.splice(keyIndex, 1);
            
            // Adjust current index if needed
            if (apiKeyManager.currentKeyIndex >= apiKeyManager.reservoirKeys.length) {
              apiKeyManager.currentKeyIndex = 0;
            }
            
            await interaction.editReply(`✅ Removed API key: ${apiKeyManager.maskApiKey(key)}`);
          }
        } catch (error) {
          console.error('Error managing API keys:', error);
          await interaction.editReply('An error occurred while managing API keys.');
        }
        break;
      }
    }
  } catch (error) {
    console.error('Error handling interaction:', error);
    // Try to respond if we haven't already
    try {
      if (interaction.deferred) {
        await interaction.editReply({
          content: 'An error occurred while processing your command. Please try again.',
          ephemeral: true
        });
      } else if (!interaction.replied) {
        await interaction.reply({
          content: 'An error occurred while processing your command. Please try again.',
          ephemeral: true
        });
      }
    } catch (replyError) {
      console.error('Failed to send error response:', replyError);
    }
  }
});

// Basic function to create a paginated embed for tracked collections
function createCollectionListEmbed(collections, guildName, page = 1, itemsPerPage = 5) {
  const collectionEntries = Object.entries(collections);
  const totalCollections = collectionEntries.length;
  const totalPages = Math.ceil(totalCollections / itemsPerPage);
  
  page = Math.max(1, Math.min(page, totalPages || 1));
  const startIndex = (page - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage, totalCollections);
  const pageItems = collectionEntries.slice(startIndex, endIndex);

  // Create a header embed
  const headerEmbed = new EmbedBuilder()
    .setColor('#2196f3') // Blue color for the sidebar
    .setTitle(`Tracked Collections`)
    .setDescription(
      totalCollections === 0
        ? 'No collections being tracked.'
        : `This server is tracking ${totalCollections} collections.`
    );
  
  if (totalPages > 1) {
    headerEmbed.setFooter({ text: `Page ${page}/${totalPages}` });
  } else {
    headerEmbed.setFooter({ text: `Today at ${new Date().toLocaleTimeString('en-US', {hour: '2-digit', minute:'2-digit'})}` });
  }

  // Create an array of embeds, starting with the header
  const embeds = [headerEmbed];
  
  // Create an embed for each collection
  let collectionNum = startIndex + 1;
  pageItems.forEach(([addr, collection]) => {
    // Get collection name, fallback to address format if not available
    const displayName = collection.name || `Collection ${addr.substring(0, 8)}...`;
    
    console.log(`Debug - Collection ${displayName} (${addr}):`, JSON.stringify(collection));
    
    // Format added by with @ mention if user ID is available
    const addedBy = collection.addedBy ? `@${getUsernameFromId(collection.addedBy) || 'user'}` : 'Unknown';
    
    // Format added date nicely
    const addedDate = collection.addedAt 
      ? new Date(collection.addedAt).toLocaleString('en-US', {
          month: 'numeric', 
          day: 'numeric', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        })
      : 'Unknown';
    
    // Create a collection embed
    const collectionEmbed = new EmbedBuilder()
      .setColor('#2196f3')
      .setTitle(`${collectionNum}. ${displayName}`)
      .setDescription(`**Address**: ${addr}\n**Added by**: ${addedBy}\n**Added on**: ${addedDate}`)
      .setTimestamp();
    
    // Add image if available - make sure it's a valid URL
    if (collection.image && typeof collection.image === 'string' && collection.image.trim() !== '') {
      console.log(`Setting image for ${displayName}: ${collection.image}`);
      
      try {
        // Sometimes special characters in URLs can cause issues, so ensure it's properly encoded
        const imageUrl = collection.image.includes('https://i.imgur.com') 
          ? collection.image  // If it's already an imgur URL, use it as is
          : encodeURI(collection.image);  // Otherwise encode it
          
        collectionEmbed.setImage(imageUrl);
        console.log(`Successfully set image URL: ${imageUrl}`);
      } catch (error) {
        console.error(`Error setting image for ${displayName}:`, error.message);
      }
    } else {
      console.log(`No image available for ${displayName}`);
    }
    
    embeds.push(collectionEmbed);
    collectionNum++;
  });
  
  return { embed: embeds, currentPage: page, totalPages };
}

// Helper function to get username from ID (mock implementation)
function getUsernameFromId(userId) {
  const user = client.users.cache.get(userId);
  return user ? user.username : null;
}

// Button row(s) for collection list pagination + untrack
function createCollectionListComponents(currentPage, totalPages, collections) {
  const components = [];
  // page nav
  if (totalPages > 1) {
    const navRow = new ActionRowBuilder();
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_prev`)
        .setLabel('Previous')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('⬅️')
        .setDisabled(currentPage <= 1)
    );
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_indicator`)
        .setLabel(`Page ${currentPage}/${totalPages}`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(true)
    );
    navRow.addComponents(
      new ButtonBuilder()
        .setCustomId(`page_${currentPage}_next`)
        .setLabel('Next')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('➡️')
        .setDisabled(currentPage >= totalPages)
    );
    components.push(navRow);
  }

  // untrack row (one button per collection on current page)
  const collectionEntries = Object.entries(collections);
  const startIndex = (currentPage - 1) * 5;
  const endIndex = Math.min(startIndex + 5, collectionEntries.length);
  const pageItems = collectionEntries.slice(startIndex, endIndex);
  
  if (pageItems.length > 0) {
    const actionRow = new ActionRowBuilder();
    pageItems.forEach(([addr, data], i) => {
      const index = startIndex + i + 1;
      let displayLabel = data.name || `Collection ${index}`;
      if (displayLabel.length > 20) {
        displayLabel = displayLabel.substring(0, 20) + '…';
      }
      actionRow.addComponents(
        new ButtonBuilder()
          .setCustomId(`untrack_${addr}_${currentPage}`)
          .setLabel(displayLabel)
          .setStyle(ButtonStyle.Danger)
          .setEmoji('🗑️')
      );
    });
    components.push(actionRow);
  }
  return components;
}

// Bot ready event
client.once('ready', async () => {
  console.log(`=== Monad NFT Sales Bot v1.4.0 ===`);
  console.log(`Bot logged in as ${client.user.tag}`);
  
  // Load server configurations first
  loadServerConfigs();
  
  // Register slash commands
  await registerSlashCommands();
  
  // Initialize and start the sales tracker
  await initializeBot();
  
  console.log('⏱️ Starting periodic checks for sales every', 
    (config.refreshInterval / 1000), 'seconds');
  
  // Start the periodic check for sales
  setInterval(async () => {
    try {
      console.log('🔄 Running periodic sales check');
      for (const serverId in serverConfigs) {
        await checkAndNotifySales(serverId);
      }
    } catch (error) {
      console.error('❌ Error in sales check interval:', error);
    }
  }, config.refreshInterval);
  
  // Set up a periodic reset of API rate limit tracking (every hour)
  setInterval(() => {
    console.log('🔄 Resetting API key rate limit status');
    apiKeyManager.resetRateLimits();
  }, 60 * 60 * 1000); // Every hour
  
  console.log('✅ Bot setup complete and ready to notify about NFT sales');
});

// Load server configurations
loadServerConfigs();

// Register slash commands 
registerSlashCommands();

// Login to Discord
client.login(config.discordToken);

// Function to periodically check for collections sales 
async function checkAndNotifySales(serverId) {
  const serverConfig = serverConfigs[serverId];
  if (!serverConfig) {
    console.log(`No configuration for server ${serverId}`);
    return;
  }
  
  // Handle both property names for backward compatibility
  const notificationChannelId = serverConfig.notificationChannelId || serverConfig.notificationChannel;
  
  if (!notificationChannelId) {
    console.log(`No notification channel for server ${serverId}`);
    return;
  }

  try {
    const guild = client.guilds.cache.get(serverId);
    if (!guild) {
      console.log(`Guild ${serverId} not found`);
      return;
    }

    const channel = guild.channels.cache.get(notificationChannelId);
    if (!channel) {
      console.log(`Channel ${notificationChannelId} not found in guild ${serverId}`);
      return;
    }

    console.log(`Running checkAndNotifySales for ${guild.name}`);
    
    // Get collection addresses for this server
    const collectionAddresses = [];
    
    // Extract from tracked collections - handle both formats
    if (serverConfig.trackedCollections) {
      for (const key in serverConfig.trackedCollections) {
        const collection = serverConfig.trackedCollections[key];
        // Handle both string and object formats
        const address = typeof collection === 'string' ? collection : collection.address;
        if (address) collectionAddresses.push(address);
      }
    }
      
    console.log(`Checking ${collectionAddresses.length} collections for ${guild.name}`);

    if (collectionAddresses.length === 0) {
      console.log(`No collections to check for server ${serverId}`);
      return;
    }

    // Process Reservoir sales
    console.log("Fetching sales via Reservoir API...");
    const reservoirSales = await fetchReservoirSales(collectionAddresses);
    console.log(`Detected ${reservoirSales.length} sales via Reservoir API`);
    
    // If no sales were detected, exit
    if (reservoirSales.length === 0) {
      return;
    }

    // Notify about each sale
    for (const sale of reservoirSales) {
      const saleId = sale.id || `reservoir_${Date.now()}`;
      
      // Check if we've already notified about this sale
      if (lastProcessedSales.processedSales.has(saleId)) {
        console.log(`🔄 Already notified about sale ${saleId}, skipping`);
        continue;
      }

      // Create and send the embed
      const embed = createSaleEmbed(sale);
      
      const collectionName = sale.collection?.name || 
                         sale.collection?.id || 
                         'Unknown Collection';
      
      console.log(`🔔 SENDING NOTIFICATION for ${collectionName} sale (${saleId})`);
      
      try {
        await channel.send({ embeds: [embed] });
        console.log(`✅ NOTIFICATION SENT SUCCESSFULLY for ${collectionName}!`);
        
        // Mark as notified - use set with timestamp
        lastProcessedSales.processedSales.set(saleId, Date.now());
        console.log(`📋 Added sale ${saleId} to processed cache`);
        
        // Trim cache if needed
        if (lastProcessedSales.processedSales.size > MAX_CACHE_SIZE) {
          const oldestKey = Array.from(lastProcessedSales.processedSales.keys())[0];
          lastProcessedSales.processedSales.delete(oldestKey);
          console.log(`🧹 Trimmed oldest sale from cache: ${oldestKey}`);
        }
      } catch (sendError) {
        console.error(`❌ ERROR SENDING NOTIFICATION: ${sendError.message}`);
      }
    }
  } catch (error) {
    console.error(`❌ Error checking and notifying sales for server ${serverId}:`, error.message);
  }
}

// Function to send a test notification
async function testNotification(guildId) {
  try {
    // Check if the server exists in the config
    if (!serverConfigs[guildId]) {
      console.log(`⚠️ No configuration found for guild ${guildId}`);
      return;
    }

    // Handle both property names for backward compatibility
    const channelId = serverConfigs[guildId].notificationChannelId || serverConfigs[guildId].notificationChannel;
    
    if (!channelId) {
      console.log(`⚠️ No notification channel configured for guild ${guildId}`);
      return;
    }

    // Get the guild and channel
    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
      console.log(`❌ Guild ${guildId} not found`);
      return;
    }

    const channel = guild.channels.cache.get(channelId);
    if (!channel) {
      console.log(`❌ Channel ${channelId} not found in guild ${guildId}`);
      return;
    }

    // Create a test sale object matching the screenshot
    const testSale = {
      id: `test_${Date.now()}`,
      type: 'Sale',
      createdAt: '2025-01-21T04:57:00.000Z', // Jan 21, 04:57 AM
      collection: {
        id: '0x3019bf1dfb84e5b46ca9d0eec37de08a59a41308',
        name: 'Nad Name Service'
      },
      price: '0.0247',
      token: {
        tokenId: '456367',
        name: 'Nad Name', // Just the name without "Service" to make it clearer for the "#token" format
        // Use the reliable Twitter image for NNS
        image: 'https://pbs.twimg.com/profile_images/1658957832532230145/WyFdTZ-L_400x400.jpg'
      },
      buyer: '0x12345678901234567890123456789012abcdef12',
      seller: '0xd37d370e52ca3d9b91c0dc8c7a535a65d6f95919',
      transaction: '0x2c8c32e5ef4a58d95a70a4e1bf4dd21e15e3cb2cb3b76c8a56ab3c79eaa3abf2'
    };

    console.log(`🔍 Test notification will show collection name: ${testSale.collection.name}`);

    // Create the embed for the notification
    const embed = createSaleEmbed(testSale);

    console.log(`📝 Test embed created with title: ${embed.data.title}`);
    console.log(`📝 Sale embed has collection field: ${embed.data.fields[0].name}: ${embed.data.fields[0].value}`);

    // Send the notification
    console.log(`📤 Sending test notification to ${guild.name} #${channel.name}`);
    await channel.send({ embeds: [embed] });
    console.log(`✅ Test notification sent successfully to ${guild.name}`);
    return true;
  } catch (error) {
    console.error(`❌ Error sending test notification to ${guild.name}:`, error.message);
    return false;
  }
}

/**
 * Initialize the bot and set up sales tracking
 */
async function initializeBot() {
  console.log('🚀 Initializing bot and setting up sales tracker...');
  
  // Initialize the lastCheckTime to track when we last checked for sales
  lastCheckTime = new Date();
  
  console.log('⏱️ Initializing with current time:', lastCheckTime.toISOString());
  
  // Collect all tracked collection addresses from all servers
  const collectionAddresses = [];
  for (const serverId in serverConfigs) {
    const serverConfig = serverConfigs[serverId];
    if (serverConfig.trackedCollections) {
      for (const key in serverConfig.trackedCollections) {
        const collection = serverConfig.trackedCollections[key];
        // Handle both string and object formats
        const address = typeof collection === 'string' ? collection : collection.address;
        if (address && !collectionAddresses.includes(address)) {
          collectionAddresses.push(address);
        }
      }
    }
  }
  
  // Fetch existing sales but don't notify
  try {
    console.log(`📋 Found ${collectionAddresses.length} collections to monitor: ${collectionAddresses.join(', ')}`);
    
    if (collectionAddresses.length > 0) {
      // Initialize sales cache by processing existing sales
      const existingSales = await fetchReservoirSales(collectionAddresses);
      console.log(`🔍 Found ${existingSales.length} existing sales to add to cache`);
      
      // Add existing sales to the notified set
      for (const sale of existingSales) {
        lastProcessedSales.processedSales.set(sale.id, Date.now());
      }
    } else {
      console.log('⚠️ No collections configured for monitoring');
    }
    
    console.log('✅ Bot initialized and ready to monitor for new sales');
  } catch (error) {
    console.error('❌ Error initializing sales cache:', error);
  }
}

/**
 * Check a single collection for sales and add to cache (but don't notify)
 * @param {string} collectionAddress The collection address to check
 * @returns {Promise<number>} The number of sales found and cached
 */
async function checkSingleCollection(collectionAddress) {
  if (!collectionAddress) return 0;
  
  console.log(`🔍 Checking single collection: ${collectionAddress}`);
  try {
    // Fetch sales for just this collection
    const sales = await fetchReservoirSales([collectionAddress]);
    
    if (sales.length > 0) {
      console.log(`📊 Found ${sales.length} existing sales for collection ${collectionAddress}`);
      
      // Add existing sales to cache to avoid immediate notifications for old sales
      for (const sale of sales) {
        const saleId = sale.id || `reservoir_${Date.now()}`;
        if (!lastProcessedSales.processedSales.has(saleId)) {
          lastProcessedSales.processedSales.set(saleId, Date.now());
          console.log(`📋 Added sale ${saleId} to processed cache`);
        }
      }
    } else {
      console.log(`📊 No existing sales found for collection ${collectionAddress}`);
    }
    
    // Log and return the count
    return sales.length;
  } catch (error) {
    console.error(`❌ Error checking single collection for sales:`, error.message);
    return 0;
  }
}

// Fix invalid image URL formats throughout the app
function cleanImageUrl(url) {
  if (!url) return null;
  
  try {
    // Remove content type information if present
    if (url.includes(';')) {
      url = url.split(';')[0];
    }
    
    // Fix broken URLs with .svg+xml format
    url = url.replace('.svg+xml', '.svg');
    
    // For Reservoir URLs, ensure we have a valid image format
    if (url.includes('reservoir.tools') && !url.match(/\.(jpeg|jpg|gif|png|svg|webp)($|\?)/i)) {
      url += (url.includes('?') ? '&' : '?') + 'format=png';
    }
    
    // Try to validate the URL
    new URL(url);
    
    return url;
  } catch (error) {
    console.error(`Invalid image URL: ${url}`, error.message);
    return null;
  }
}
